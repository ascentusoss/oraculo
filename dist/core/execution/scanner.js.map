{"version":3,"file":"scanner.js","sourceRoot":"","sources":["../../../src/core/execution/scanner.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\nimport type { Dirent, Stats } from 'node:fs';\nimport { promises as fs } from 'node:fs';\n\nimport { config } from '@core/config/config.js';\nimport { ExcecoesMessages } from '@core/messages/core/excecoes-messages.js';\nimport { logScanner } from '@core/messages/log/log-helper.js';\nimport {\n  lerArquivoTexto,\n  lerEstado,\n} from '@shared/persistence/persistencia.js';\nimport micromatch from 'micromatch';\nimport path from 'path';\n\nimport type { FileEntry, FileMap, ScanOptions } from '@';\n\nexport type { ScanOptions };\n\nexport async function scanRepository(\n  baseDir: string,\n  options: ScanOptions = {},\n): Promise<FileMap> {\n  // Log de in√≠cio da varredura\n  logScanner.iniciarVarredura(baseDir);\n\n  // Helpers locais de normaliza√ß√£o (n√£o exportados)\n  const toPosix = (s: string) => s.replace(/\\\\+/g, '/');\n  const trimDotSlash = (s: string) => s.replace(/^\\.\\/?/, '');\n\n  const {\n    includeContent = true,\n    filter = () => true,\n    onProgress = () => {\n      return undefined;\n    },\n  } = options;\n  // Em modo scan-only, n√£o devemos ler conte√∫dos de arquivos\n  const efetivoIncluirConteudo = includeContent && !config.SCAN_ONLY;\n\n  const fileMap: FileMap = {};\n  const statCache = new Map<string, Stats>();\n  // üî• CONFIGURA√á√ÉO SIMPLIFICADA - Apenas CLI e exclude global\n  const gruposRaw =\n    (config as unknown as { CLI_INCLUDE_GROUPS?: string[][] })\n      .CLI_INCLUDE_GROUPS || [];\n  const includeGroups = Array.isArray(gruposRaw) ? gruposRaw : [];\n  const includeGroupsNorm: string[][] = includeGroups.map((g) =>\n    (g || []).map((p) => toPosix(trimDotSlash(String(p || '')))),\n  );\n\n  const includePatterns = Array.isArray(config.CLI_INCLUDE_PATTERNS)\n    ? (config.CLI_INCLUDE_PATTERNS as string[])\n    : [];\n  const includePatternsNorm = includePatterns.map((p) =>\n    toPosix(trimDotSlash(String(p || ''))),\n  );\n\n  const excludePatternsNorm = (\n    Array.isArray(config.CLI_EXCLUDE_PATTERNS)\n      ? (config.CLI_EXCLUDE_PATTERNS as string[])\n      : []\n  ).map((p) => toPosix(String(p || '')));\n\n  // üìå √öNICO PONTO DE EXCLUDE: globalExcludeGlob da configura√ß√£o legacy ou campo simplificado\n  const legacyExcludes = config.INCLUDE_EXCLUDE_RULES?.globalExcludeGlob || [];\n  const ignorePatternsNorm = (legacyExcludes as string[]).map((p: string) =>\n    toPosix(String(p || '')),\n  );\n\n  const hasInclude =\n    includeGroupsNorm.length > 0 || includePatternsNorm.length > 0;\n  // Sinaliza quando os includes pedem ocorr√™ncias em qualquer profundidade (ex.: '**/nome/**') ou quando\n  // o usu√°rio forneceu nomes simples (que o expandIncludes converte em '**/nome/**').\n  const pedeOcorrenciasGlobais = hasInclude\n    ? [...includePatternsNorm, ...includeGroupsNorm.flat()].some((p) =>\n        p.startsWith('**/'),\n      )\n    : false;\n  // node_modules explicitamente inclu√≠do em algum pattern ou grupo de include\n  const includeNodeModulesExplicit = hasInclude\n    ? [...includePatternsNorm, ...includeGroupsNorm.flat()].some((p) =>\n        /(^|\\/)node_modules(\\/|$)/.test(String(p || '')),\n      )\n    : false;\n\n  // Quando includes est√£o ativos, derivamos diret√≥rios-raiz a partir dos prefixos antes do primeiro metacaractere\n\n  function calcularIncludeRoots(\n    padroes: string[] | undefined,\n    grupos?: string[][],\n  ): string[] {\n    const roots = new Set<string>();\n    const candidatos = new Set<string>();\n    if (Array.isArray(padroes))\n      padroes.forEach((p) => candidatos.add(toPosix(trimDotSlash(p))));\n    if (Array.isArray(grupos))\n      for (const g of grupos)\n        g.forEach((p) => candidatos.add(toPosix(trimDotSlash(p))));\n    if (candidatos.size === 0) return [];\n    const META = /[\\\\*\\?\\{\\}\\[\\]]/; // caracteres meta de glob\n    for (const raw of candidatos) {\n      let p = String(raw).trim();\n      if (!p) continue;\n      p = toPosix(trimDotSlash(p));\n      let anchor = '';\n      if (p.includes('/**')) anchor = p.slice(0, p.indexOf('/**'));\n      else if (p.includes('/*')) anchor = p.slice(0, p.indexOf('/*'));\n      else if (p.includes('/')) anchor = p.split('/')[0];\n      else anchor = '';\n      anchor = anchor.replace(/\\/+/g, '/').replace(/\\/$/, '');\n      // Ignora anchors inv√°lidos: vazios, apenas '.', '**' ou contendo metacaracteres (ex.: '**/src')\n      if (anchor && anchor !== '.' && anchor !== '**' && !META.test(anchor)) {\n        const baseNorm = toPosix(String(baseDir)).replace(/\\/$/, '');\n        const rootPosix = `${baseNorm}/${anchor}`.replace(/\\/+/g, '/');\n        roots.add(rootPosix);\n      }\n    }\n    return Array.from(roots);\n  }\n\n  // Matcher de include considerando grupos: AND dentro do grupo, OR entre grupos\n\n  function matchInclude(relPath: string): boolean {\n    // Fun√ß√£o auxiliar: avalia se um padr√£o casa com o caminho relativo\n    const matchesPattern = (rp: string, p: string): boolean => {\n      if (!p) return false;\n      // Casamento direto via micromatch\n      if (micromatch.isMatch(rp, [p])) return true;\n      // Compat extra: reconhece padr√µes simples com sufixo '/**' por prefixo\n      if (p.endsWith('/**')) {\n        const base = p.slice(0, -3); // remove '/**'\n        if (base && rp.startsWith(base)) return true;\n      }\n      // Quando o padr√£o n√£o possui metacaracteres, trate como diret√≥rio/segmento\n      const META = /[\\\\*\\?\\{\\}\\[\\]]/;\n      if (!META.test(p)) {\n        const pat = p.replace(/\\/+$|\\/+$|^\\.\\/?/g, '').replace(/\\/+/g, '/');\n        if (!pat) return false;\n        // Se cont√©m barra: trate como caminho base (prefixo)\n        if (pat.includes('/')) {\n          if (rp === pat) return true;\n          if (rp.startsWith(`${pat}/`)) return true;\n          if (rp.includes(`/${pat}/`)) return true;\n          if (rp.endsWith(`/${pat}`)) return true;\n          return false;\n        }\n        // Segmento simples: casa em qualquer n√≠vel\n        if (rp === pat) return true;\n        if (rp.startsWith(`${pat}/`)) return true;\n        if (rp.includes(`/${pat}/`)) return true;\n        if (rp.endsWith(`/${pat}`)) return true;\n        return false;\n      }\n      return false;\n    };\n    // Fun√ß√£o auxiliar: extrai a \"base\" do padr√£o (token original antes das amplia√ß√µes)\n    const baseFromPattern = (p: string): string => {\n      let b = p.trim();\n      b = b.replace(/^\\*\\*\\//, ''); // remove '**/' inicial\n      b = b.replace(/\\/\\*\\*$/, ''); // remove '/**' final\n      b = b.replace(/^\\.\\/?/, ''); // remove './' inicial\n      b = b.replace(/\\/+/g, '/').replace(/\\/$/, '');\n      return b;\n    };\n    // Quando houver grupos, aplica estritamente: OR entre grupos com AND dentro do grupo\n    if (includeGroupsNorm.length > 0) {\n      for (const g of includeGroupsNorm) {\n        // Agrupa padr√µes por base (permite OR entre variantes de um mesmo token e AND entre tokens)\n        const porBase = new Map<string, string[]>();\n        for (const p of g) {\n          const base = baseFromPattern(p);\n          const patternVariants = porBase.get(base) || [];\n          patternVariants.push(p);\n          porBase.set(base, patternVariants);\n        }\n        const allBasesMatch = Array.from(porBase.values()).every((lista) =>\n          lista.some((p) => matchesPattern(relPath, p)),\n        );\n        if (allBasesMatch) return true;\n      }\n      // Sem correspond√™ncia em nenhum grupo -> n√£o inclui\n      return false;\n    }\n    // Sem grupos: lista achatada (OR)\n    if (\n      includePatternsNorm.length &&\n      micromatch.isMatch(relPath, includePatternsNorm)\n    )\n      return true;\n    // Compat extra tamb√©m para padr√µes simples quando n√£o h√° grupos\n    for (const p of includePatternsNorm || [])\n      if (matchesPattern(relPath, p)) return true;\n    return false;\n  }\n\n  async function scan(dir: string): Promise<void> {\n    let entries: Dirent[];\n    try {\n      entries = await fs.readdir(dir, { withFileTypes: true });\n      entries.sort((a, b) => a.name.localeCompare(b.name));\n    } catch (err) {\n      onProgress(\n        JSON.stringify({\n          tipo: 'erro',\n          acao: 'acessar',\n          caminho: dir,\n          mensagem:\n            typeof err === 'object' && err && 'message' in err\n              ? (err as { message: string }).message\n              : String(err),\n        }),\n      );\n      return;\n    }\n\n    // Logar apenas diret√≥rios sendo examinados\n    onProgress(\n      JSON.stringify({ tipo: 'diretorio', acao: 'examinar', caminho: dir }),\n    );\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n      const relPathRaw = path.relative(baseDir, fullPath);\n      // Normaliza para separador POSIX para que micromatch funcione de forma consistente no Windows\n      const relPath = toPosix(relPathRaw);\n\n      // Regra fixa do Or√°culo: n√£o analisar testes (deixa para o runner, ex.: Vitest)\n      const isTestLike = (p: string): boolean => {\n        const rp = toPosix(p);\n        if (/(^|\\/)__(tests|mocks)__(\\/|$)/.test(rp)) return true;\n        if (/(^|\\/)(tests?|test)(\\/|$)/.test(rp)) return true;\n        if (/\\.(test|spec)\\.[jt]sx?$/.test(rp)) return true;\n        return false;\n      };\n      if (isTestLike(relPath)) {\n        continue;\n      }\n      /* -------------------------- - -------------------------- */\n      // Filtros de inclus√£o/exclus√£o aplicados corretamente: diret√≥rios x arquivos\n      if (entry.isDirectory() && !entry.isSymbolicLink()) {\n        // Diret√≥rios: aplica excludes e ignores padr√£o (ignores somente quando n√£o h√° include),\n        // al√©m de guarda espec√≠fica para node_modules.\n        // Aplica exclus√µes APENAS quando n√£o h√° includes ativos\n        if (!hasInclude && micromatch.isMatch(relPath, excludePatternsNorm)) {\n          continue; // diret√≥rio exclu√≠do explicitamente (somente quando n√£o h√° include ativo)\n        }\n        if (!hasInclude && micromatch.isMatch(relPath, ignorePatternsNorm)) {\n          continue; // ignora diret√≥rios padr√£o quando n√£o h√° include\n        }\n        if (\n          /(^|\\/)node_modules(\\/|$)/.test(relPath) &&\n          !includeNodeModulesExplicit\n        ) {\n          continue; // prote√ß√£o: n√£o descer em node_modules salvo inclus√£o expl√≠cita\n        }\n        await scan(fullPath);\n      } else {\n        // Arquivos: aplica include (quando presente), excludes/ignores e filtro customizado\n        if (hasInclude && !matchInclude(relPath)) {\n          continue; // arquivo n√£o incluso explicitamente\n        }\n        // Aplica exclus√µes APENAS quando n√£o h√° includes ativos ou quando o arquivo n√£o passa no include\n        if (!hasInclude && micromatch.isMatch(relPath, excludePatternsNorm)) {\n          continue; // arquivo exclu√≠do (somente quando n√£o h√° include ativo)\n        }\n        if (!hasInclude && micromatch.isMatch(relPath, ignorePatternsNorm)) {\n          continue; // ignore padr√£o quando n√£o h√° include\n        }\n        // Filtro customizado (sempre aplica)\n        if (!filter(relPath, entry)) {\n          continue; // filtro customizado\n        }\n        try {\n          // Tenta obter stat; se rejeitar, registra erro e n√£o inclui arquivo\n          let stat: unknown = statCache.get(fullPath);\n          if (!stat) {\n            try {\n              stat = await fs.stat(fullPath);\n              statCache.set(fullPath, stat as Stats);\n            } catch (e) {\n              onProgress(\n                JSON.stringify({\n                  tipo: 'erro',\n                  acao: 'ler',\n                  caminho: relPath,\n                  mensagem:\n                    typeof e === 'object' && e && 'message' in e\n                      ? (e as { message: string }).message\n                      : String(e),\n                }),\n              );\n              continue;\n            }\n          }\n          if (stat == null) {\n            throw new Error(ExcecoesMessages.statIndefinidoPara(fullPath));\n          }\n          let mtimeMs = 0;\n          if (\n            typeof stat === 'object' &&\n            stat &&\n            'mtimeMs' in (stat as Stats)\n          ) {\n            const mm = (stat as Stats).mtimeMs;\n            if (typeof mm === 'number') mtimeMs = mm;\n          }\n\n          let content: string | null = null;\n          if (efetivoIncluirConteudo) {\n            const emTeste = !!process.env.VITEST;\n            try {\n              if (emTeste) {\n                // Mant√©m compat com testes que mockam lerEstado\n                content = await lerEstado<string>(fullPath);\n              } else {\n                content = await lerArquivoTexto(fullPath);\n              }\n            } catch (e) {\n              // Em caso de erro de leitura, registra via onProgress e segue\n              onProgress(\n                JSON.stringify({\n                  tipo: 'erro',\n                  acao: 'ler',\n                  caminho: relPath,\n                  mensagem:\n                    typeof e === 'object' && e && 'message' in e\n                      ? (e as { message: string }).message\n                      : String(e),\n                }),\n              );\n              content = null;\n            }\n          }\n\n          const entryObj: FileEntry = {\n            fullPath,\n            relPath,\n            content,\n            ultimaModificacao: mtimeMs,\n          };\n\n          fileMap[relPath] = entryObj;\n          // Logar cada arquivo individualmente para compatibilidade com testes\n          // Evita ru√≠do quando relat√≥rios silenciosos est√£o ativos (modo --json)\n          if (!config.REPORT_SILENCE_LOGS) {\n            onProgress(`‚úÖ Arquivo lido: ${relPath}`);\n          }\n        } catch (err) {\n          onProgress(\n            JSON.stringify({\n              tipo: 'erro',\n              acao: 'ler',\n              caminho: relPath,\n              mensagem:\n                typeof err === 'object' && err && 'message' in err\n                  ? (err as { message: string }).message\n                  : String(err),\n            }),\n          );\n        }\n      }\n    }\n  }\n\n  // Pontos de partida da varredura\n  let startDirs = hasInclude\n    ? calcularIncludeRoots(\n        config.CLI_INCLUDE_PATTERNS as string[] | undefined,\n        (config as unknown as { CLI_INCLUDE_GROUPS?: string[][] })\n          .CLI_INCLUDE_GROUPS,\n      )\n    : [];\n  // Quando o include pede ocorr√™ncias em qualquer profundidade, adicionamos tamb√©m a base do repo para\n  // garantir que diret√≥rios-alvo apare√ßam em n√≠veis arbitr√°rios (ex.: packages/*/node_modules).\n  if (hasInclude && pedeOcorrenciasGlobais) {\n    const baseNorm = toPosix(String(baseDir)).replace(/\\/$/, '');\n    if (!startDirs.includes(baseNorm)) startDirs = [baseNorm, ...startDirs];\n  }\n  // Se nenhum root foi derivado (ex.: includes somente de arquivos como 'a.txt'), varremos a base inteira\n  // para permitir que o filtro de includes atue nos arquivos diretamente.\n  if (hasInclude && startDirs.length === 0) {\n    // Sem roots deriv√°veis (ex.: include apenas 'a.txt'): varre s√≥ a raiz para permitir filtro\n    await scan(baseDir);\n    return fileMap;\n  }\n  if (startDirs.length === 0) {\n    await scan(baseDir);\n  } else {\n    const vistos = new Set<string>();\n    for (const d of startDirs) {\n      // Evita normaliza√ß√£o com path.resolve para n√£o quebrar mocks de testes (mant√©m separador POSIX)\n      let norm = d;\n      // Remove barra final para compat com mocks que comparam por igualdade\n      if (/[\\\\\\/]$/.test(norm)) norm = norm.replace(/[\\\\\\/]+$/, '');\n      if (vistos.has(norm)) continue;\n      vistos.add(norm);\n      // Tenta primeiro tratar como diret√≥rio sem depender de stat (mocks podem retornar fun√ß√µes)\n      try {\n        await fs.readdir(norm);\n        await scan(norm);\n        continue;\n      } catch {\n        // n√£o √© diret√≥rio (ou inacess√≠vel); tenta fluxo de arquivo abaixo\n      }\n      // Quando o root derivado for um arquivo, processe-o diretamente\n      try {\n        let st = statCache.get(norm);\n        if (!st) {\n          st = await fs.stat(norm);\n          statCache.set(norm, st);\n        }\n        let isDir = false;\n        if (\n          st &&\n          typeof (st as unknown as { isDirectory: () => boolean })\n            .isDirectory === 'function'\n        ) {\n          isDir = st.isDirectory();\n        } else {\n          // Fallback quando stat mockado n√£o possui isDirectory confi√°vel: tenta readdir\n          try {\n            await fs.readdir(norm);\n            isDir = true;\n          } catch {\n            isDir = false;\n          }\n        }\n        if (isDir) {\n          await scan(norm);\n        } else {\n          // Alguns testes mockam stat.isDirectory() como false mesmo para diret√≥rios;\n          // se conseguirmos listar, tratamos como diret√≥rio.\n          try {\n            await fs.readdir(norm);\n            await scan(norm);\n            continue;\n          } catch {\n            // segue como arquivo\n          }\n          const relPathRaw = path.relative(baseDir, norm);\n          const relPath = toPosix(relPathRaw);\n          // Aplica as mesmas regras de filtragem de arquivos\n          if (hasInclude && !matchInclude(relPath)) {\n            continue;\n          }\n          // Aplica exclus√µes APENAS quando n√£o h√° includes ativos\n          if (!hasInclude && micromatch.isMatch(relPath, excludePatternsNorm)) {\n            continue;\n          }\n          if (!hasInclude && micromatch.isMatch(relPath, ignorePatternsNorm)) {\n            continue;\n          }\n          // Filtro customizado exige Dirent; criamos um stub m√≠nimo\n          const fakeDirent: Dirent = {\n            name: path.basename(norm),\n            isDirectory: () => false,\n            isSymbolicLink: () => false,\n          } as unknown as Dirent;\n          // Filtro customizado (sempre aplica quando include est√° ativo)\n          if (!filter(relPath, fakeDirent)) continue;\n\n          let content: string | null = null;\n          if (efetivoIncluirConteudo) {\n            const emTeste = !!process.env.VITEST;\n            try {\n              if (emTeste) content = await lerEstado<string>(norm);\n              else content = await lerArquivoTexto(norm);\n            } catch (e) {\n              onProgress(\n                JSON.stringify({\n                  tipo: 'erro',\n                  acao: 'ler',\n                  caminho: relPath,\n                  mensagem:\n                    typeof e === 'object' && e && 'message' in e\n                      ? (e as { message: string }).message\n                      : String(e),\n                }),\n              );\n              content = null;\n            }\n          }\n\n          fileMap[relPath] = {\n            fullPath: norm,\n            relPath,\n            content,\n            ultimaModificacao:\n              (st && 'mtimeMs' in st ? (st as Stats).mtimeMs : Date.now()) ||\n              Date.now(),\n          };\n          if (!config.REPORT_SILENCE_LOGS) {\n            onProgress(`‚úÖ Arquivo lido: ${relPath}`);\n          }\n        }\n      } catch (e) {\n        onProgress(\n          JSON.stringify({\n            tipo: 'erro',\n            acao: 'acessar',\n            caminho: norm,\n            mensagem:\n              typeof e === 'object' && e && 'message' in e\n                ? (e as { message: string }).message\n                : String(e),\n          }),\n        );\n      }\n    }\n  }\n\n  // Log de conclus√£o da varredura\n  const totalArquivos = Object.keys(fileMap).length;\n  const totalDiretorios = new Set(\n    Object.values(fileMap).map((f) => path.dirname(f.relPath)),\n  ).size;\n\n  logScanner.completo(totalArquivos, totalDiretorios);\n\n  return fileMap;\n}\n"]}