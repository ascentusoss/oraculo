{"version":3,"file":"analistas.js","sourceRoot":"","sources":["../../../src/types/comum/analistas.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,gBAAgB,EAAE,MAAM,0CAA0C,CAAC;AA2C5E,MAAM,UAAU,aAAa,CAAqB,GAAM;IACtD,IAAI,CAAC,GAAG,IAAI,OAAO,GAAG,KAAK,QAAQ;QACjC,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,yBAAyB,CAAC,CAAC;IAC9D,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,CAAC,KAAK,KAAK,EAAE,CAAC;IAE7D,CAAC;IACD,IAAI,OAAO,GAAG,CAAC,OAAO,KAAK,UAAU;QACnC,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,wBAAwB,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;IACvE,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC5B,CAAC;AAED,MAAM,UAAU,UAAU,CAAC,IAAwB;IACjD,OAAO,CACL,MAAM,IAAI,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CACxE,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,UAAU,CACxB,KAA6B;IAE7B,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE;QAEvB,MAAM,IAAI,GAAG,GAAgD,CAAC;QAE9D,MAAM,IAAI,GACR,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC;YAC3D,CAAC,CAAE,IAAI,CAAC,IAAe;YACvB,CAAC,CAAC,mBAAmB,CAAC;QAE1B,MAAM,MAAM,GACV,IAAI,IAAI,QAAQ,IAAI,IAAI;YACtB,CAAC,CAAE,IAAI,CAAC,MAA8B;YACtC,CAAC,CAAC,SAAS,CAAC;QAChB,MAAM,IAAI,GACR,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU;YACrC,CAAC,CAAE,IAAI,CAAC,IAA+B;YACvC,CAAC,CAAC,SAAS,CAAC;QAGhB,MAAM,OAAO,GACX,IAAI,IAAI,OAAO,IAAI,CAAC,OAAO,KAAK,UAAU;YACxC,CAAC,CAAC,KAAK,EACH,QAAgB,EAChB,OAAe,EACf,GAAkB,EAClB,QAAiB,EACjB,cAA6C,EAC7C,EAAE;gBACF,MAAM,QAAQ,GAAG,GAET,CAAC;gBAGT,MAAM,SAAS,GAAG,IAAI,CAAC,OAAwC,CAAC;gBAChE,OAAO,MAAM,SAAS,CACpB,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,QAAQ,EACR,cAAc,CACf,CAAC;YACJ,CAAC;YACH,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC,EAAE,CAAC;QAErB,OAAO;YACL,IAAI;YACJ,MAAM;YACN,IAAI;YACJ,OAAO;SACe,CAAC;IAC3B,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\n\nimport type { NodePath } from '@babel/traverse';\nimport type { Node } from '@babel/types';\nimport { ExcecoesMessages } from '@core/messages/core/excecoes-messages.js';\n\nimport type { ContextoExecucao, Ocorrencia } from '@';\n\n/**\n * Resultado que uma técnica pode retornar\n */\nexport type TecnicaAplicarResultado =\n  | Ocorrencia\n  | Ocorrencia[]\n  | null\n  | undefined;\n\n/**\n * Interface base para técnicas - versão unificada e compatível\n */\nexport interface Tecnica {\n  nome?: string;\n  global?: boolean;\n  test?: (relPath: string) => boolean;\n  aplicar: (\n    src: string,\n    relPath: string,\n    ast: NodePath<Node> | null,\n    fullPath?: string,\n    contexto?: ContextoExecucao,\n  ) => TecnicaAplicarResultado | Promise<TecnicaAplicarResultado>;\n}\n\n/**\n * Interface para analistas - superset de Técnica\n */\nexport interface Analista extends Tecnica {\n  nome: string; // obrigatório para identificação\n  categoria?: string; // ex: 'complexidade', 'estrutura'\n  descricao?: string; // breve resumo exibido em listagens\n  limites?: Record<string, number>; // ex: { maxLinhas: 30 }\n  sempreAtivo?: boolean; // ignora filtros\n}\n\n/**\n * Fábrica para criar analista com validação mínima\n */\nexport function criarAnalista<A extends Analista>(def: A): A {\n  if (!def || typeof def !== 'object')\n    throw new Error(ExcecoesMessages.definicaoAnalistaInvalida);\n  if (!def.nome || (/\\s/.test(def.nome) === false) === false) {\n    // nome pode ter hifens, apenas exige não vazio\n  }\n  if (typeof def.aplicar !== 'function')\n    throw new Error(ExcecoesMessages.analistaSemFuncaoAplicar(def.nome));\n  return Object.freeze(def);\n}\n\nexport function isAnalista(item: Tecnica | Analista): item is Analista {\n  return (\n    'nome' in item && typeof item.nome === 'string' && item.nome.length > 0\n  );\n}\n\nexport function asTecnicas(\n  items: (Tecnica | Analista)[],\n): import('@').Tecnica[] {\n  return items.map((raw) => {\n    // Trate o item como desconhecido e faça guards em runtime para evitar exceptions\n    const item = raw as unknown as Record<string, unknown> | null;\n\n    const nome =\n      item && typeof item.nome === 'string' && item.nome.length > 0\n        ? (item.nome as string)\n        : 'analista-sem-nome';\n\n    const global =\n      item && 'global' in item\n        ? (item.global as boolean | undefined)\n        : undefined;\n    const test =\n      item && typeof item.test === 'function'\n        ? (item.test as (r: string) => boolean)\n        : undefined;\n\n    // preparar aplicar com fallback seguro (no-op retorna array vazio)\n    const aplicar =\n      item && typeof item.aplicar === 'function'\n        ? async (\n            conteudo: string,\n            relPath: string,\n            ast: object | null,\n            fullPath?: string,\n            contextoGlobal?: import('@').ContextoExecucao,\n          ) => {\n            const astParam = ast as\n              | import('@babel/traverse').NodePath<import('@babel/types').Node>\n              | null;\n\n            // Chamamos usando a assinatura esperada da Técnica, sem `any`.\n            const aplicarFn = item.aplicar as unknown as Tecnica['aplicar'];\n            return await aplicarFn(\n              conteudo,\n              relPath,\n              astParam,\n              fullPath,\n              contextoGlobal,\n            );\n          }\n        : async () => [];\n\n    return {\n      nome,\n      global,\n      test,\n      aplicar,\n    } as import('@').Tecnica;\n  });\n}\n"]}