{"version":3,"file":"type-validator.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/type-validator.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Validação de tipos criados/modificados\n * Verifica compatibilidade e compilação TypeScript\n */\n\nimport type { TypeAnalysis, TypeReplacementValidation } from '@';\n\nimport { findExistingType, isSameType } from './type-creator.js';\n\n/**\n * Valida substituição de tipo (any/unknown → specific)\n */\nexport async function validateTypeReplacement(\n  originalCode: string,\n  fixedCode: string,\n  typeAnalysis: TypeAnalysis,\n): Promise<TypeReplacementValidation> {\n  const result: TypeReplacementValidation = {\n    isCompatible: true,\n    expectedType: typeAnalysis.inferredType,\n    errors: [],\n    warnings: [],\n  };\n\n  // 1. Verificar se tipo criado já existe com definição diferente\n  if (typeAnalysis.createdNewType) {\n    const existingType = await findExistingType(typeAnalysis.typeName);\n    if (\n      existingType &&\n      !isSameType(existingType, typeAnalysis.typeDefinition)\n    ) {\n      result.warnings.push(\n        `Tipo ${typeAnalysis.typeName} já existe com definição diferente. ` +\n          `Verifique conflito em ${existingType.path}`,\n      );\n    }\n  }\n\n  // 2. Verificar se tipo inferido é compatível com uso\n  const usageValidation = validateTypeUsageCompatibility(\n    fixedCode,\n    typeAnalysis,\n  );\n  if (!usageValidation.isCompatible) {\n    result.errors.push(\n      `Tipo inferido ${typeAnalysis.inferredType} incompatível com uso detectado. ` +\n        `Esperado: ${usageValidation.expectedType}`,\n    );\n    result.isCompatible = false;\n  }\n\n  // 3. Verificar se import foi adicionado corretamente\n  if (typeAnalysis.requiresImport) {\n    const hasCorrectImport =\n      fixedCode.includes(`import type { ${typeAnalysis.typeName} }`) ||\n      fixedCode.includes(`import { type ${typeAnalysis.typeName} }`);\n\n    if (!hasCorrectImport) {\n      result.errors.push(\n        `Import de tipo ${typeAnalysis.typeName} não encontrado`,\n      );\n      result.isCompatible = false;\n    }\n  }\n\n  // 4. Verificar confiança mínima\n  if (typeAnalysis.confidence < 60) {\n    result.warnings.push(\n      `Confiança muito baixa (${typeAnalysis.confidence}%). Considere revisão manual.`,\n    );\n  }\n\n  // 5. Validar sintaxe básica do código modificado\n  const syntaxValidation = validateBasicSyntax(fixedCode);\n  if (!syntaxValidation.isValid) {\n    result.errors.push(...syntaxValidation.errors);\n    result.isCompatible = false;\n  }\n\n  return result;\n}\n\n/**\n * Valida compatibilidade do tipo inferido com uso real\n */\nfunction validateTypeUsageCompatibility(\n  code: string,\n  typeAnalysis: TypeAnalysis,\n): { isCompatible: boolean; expectedType: string } {\n  // Simplificado - em produção, usar TypeScript compiler API\n  // para verificação completa\n\n  // Por enquanto, considerar compatível se confiança >= 70%\n  const isCompatible = typeAnalysis.confidence >= 70;\n\n  return {\n    isCompatible,\n    expectedType: typeAnalysis.inferredType,\n  };\n}\n\n/**\n * Valida sintaxe básica do código\n */\nfunction validateBasicSyntax(code: string): {\n  isValid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  // Verificar balanceamento de chaves\n  const braceCount =\n    (code.match(/{/g) || []).length - (code.match(/}/g) || []).length;\n  if (braceCount !== 0) {\n    errors.push(`Chaves desbalanceadas: diferença de ${Math.abs(braceCount)}`);\n  }\n\n  // Verificar balanceamento de parênteses\n  const parenCount =\n    (code.match(/\\(/g) || []).length - (code.match(/\\)/g) || []).length;\n  if (parenCount !== 0) {\n    errors.push(\n      `Parênteses desbalanceados: diferença de ${Math.abs(parenCount)}`,\n    );\n  }\n\n  // Verificar balanceamento de colchetes\n  const bracketCount =\n    (code.match(/\\[/g) || []).length - (code.match(/\\]/g) || []).length;\n  if (bracketCount !== 0) {\n    errors.push(\n      `Colchetes desbalanceados: diferença de ${Math.abs(bracketCount)}`,\n    );\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n  };\n}\n\n/**\n * Simula compilação TypeScript (simplificado)\n * Em produção, usar TypeScript compiler API\n */\nexport function runTypeScriptCompiler(code: string): {\n  hasErrors: boolean;\n  errors: string[];\n} {\n  // Simplificado - validações básicas\n  const errors: string[] = [];\n\n  // Verificar imports malformados\n  const importLines = code\n    .split('\\n')\n    .filter((line) => line.trim().startsWith('import'));\n\n  for (const line of importLines) {\n    if (!line.includes('from') && !line.includes('=')) {\n      errors.push(`Import malformado: ${line.trim()}`);\n    }\n  }\n\n  // Verificar sintaxe de interface\n  const interfaceRegex = /interface\\s+\\w+\\s*{[^}]*}/g;\n  const interfaces = code.match(interfaceRegex) || [];\n\n  for (const iface of interfaces) {\n    // Verificar propriedades\n    const properties = iface.match(/\\w+\\s*\\??\\s*:\\s*[\\w\\[\\]<>|&\\s]+;/g);\n    if (!properties) {\n      errors.push(`Interface malformada: ${iface.substring(0, 50)}...`);\n    }\n  }\n\n  return {\n    hasErrors: errors.length > 0,\n    errors,\n  };\n}\n"]}