{"version":3,"file":"usage-analyzer.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/usage-analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Analisador de uso de variáveis via AST Babel\n * Detecta padrões de uso para inferir tipos corretos\n */\n\nimport type { Node } from '/types';\n\nimport type {\n  ASTNode,\n  PropertyUsage,\n  TypeGuard,\n  UsagePattern,\n  VariableUsage,\n} from '@';\n\n/**\n * Encontra todos os usos de uma variável no AST\n */\nexport function findVariableUsages(\n  varName: string,\n  ast: Node | null,\n): VariableUsage[] {\n  const usages: VariableUsage[] = [];\n\n  if (!ast || typeof ast !== 'object') {\n    return usages;\n  }\n\n  // Traversar AST recursivamente\n  traverseAST(ast, (node: ASTNode) => {\n    // Identifier usage\n    if (node.type === 'Identifier' && node.name === varName) {\n      const usage = extractUsageFromNode(node, varName);\n      if (usage) {\n        usages.push(usage);\n      }\n    }\n\n    // Member expression (obj.property)\n    if (node.type === 'MemberExpression' && node.object?.name === varName) {\n      const usage = extractMemberExpressionUsage(node, varName);\n      if (usage) {\n        usages.push(usage);\n      }\n    }\n\n    // Call expression (func())\n    if (\n      node.type === 'CallExpression' &&\n      node.callee?.object?.name === varName\n    ) {\n      const usage = extractCallExpressionUsage(node, varName);\n      if (usage) {\n        usages.push(usage);\n      }\n    }\n  });\n\n  return usages;\n}\n\n/**\n * Analisa padrões de uso para inferir tipo\n */\nexport function analyzeUsagePatterns(usages: VariableUsage[]): UsagePattern {\n  const pattern: UsagePattern = {\n    allUsagesAreString: false,\n    allUsagesAreNumber: false,\n    allUsagesAreBoolean: false,\n    hasObjectStructure: false,\n    hasTypeGuards: false,\n    isFunction: false,\n    isArray: false,\n  };\n\n  if (usages.length === 0) {\n    return pattern;\n  }\n\n  // Detectar métodos de string\n  const stringMethods = [\n    'toUpperCase',\n    'toLowerCase',\n    'trim',\n    'substring',\n    'charAt',\n    'indexOf',\n  ];\n  const stringUsages = usages.filter(\n    (u) =>\n      u.operation === 'call' && u.method && stringMethods.includes(u.method),\n  );\n\n  // Detectar métodos de number\n  const numberOperations = usages.filter(\n    (u) =>\n      u.operation === 'call' &&\n      (u.method === 'toFixed' ||\n        u.method === 'toPrecision' ||\n        u.context.includes('+') ||\n        u.context.includes('-') ||\n        u.context.includes('*') ||\n        u.context.includes('/')),\n  );\n\n  // Detectar métodos de boolean\n  const booleanUsages = usages.filter(\n    (u) =>\n      u.operation === 'comparison' ||\n      u.context.includes('===') ||\n      u.context.includes('!==') ||\n      u.context.includes('&&') ||\n      u.context.includes('||'),\n  );\n\n  // Detectar acesso a propriedades (objeto)\n  const propertyAccesses = usages.filter(\n    (u) => u.operation === 'access' && u.property,\n  );\n\n  // Detectar chamadas de função\n  const functionCalls = usages.filter(\n    (u) => u.operation === 'call' && !u.method,\n  );\n\n  // Detectar métodos de array\n  const arrayMethods = [\n    'push',\n    'pop',\n    'map',\n    'filter',\n    'reduce',\n    'forEach',\n    'find',\n  ];\n  const arrayUsages = usages.filter(\n    (u) =>\n      u.operation === 'call' && u.method && arrayMethods.includes(u.method),\n  );\n\n  // Análise final\n  pattern.allUsagesAreString =\n    stringUsages.length > 0 && stringUsages.length === usages.length;\n  pattern.allUsagesAreNumber =\n    numberOperations.length > 0 && numberOperations.length === usages.length;\n  pattern.allUsagesAreBoolean =\n    booleanUsages.length > 0 && booleanUsages.length === usages.length;\n  pattern.hasObjectStructure = propertyAccesses.length > 0;\n  pattern.isFunction = functionCalls.length > 0;\n  pattern.isArray = arrayUsages.length > 0;\n\n  // Extrair propriedades de objeto\n  if (pattern.hasObjectStructure) {\n    pattern.objectProperties = extractObjectProperties(usages);\n  }\n\n  // Detectar type guards\n  const typeGuards = detectTypeGuards(usages);\n  if (typeGuards.length > 0) {\n    pattern.hasTypeGuards = true;\n    pattern.typeGuards = typeGuards;\n  }\n\n  return pattern;\n}\n\n/**\n * Extrai propriedades de objeto baseado em acessos\n */\nfunction extractObjectProperties(usages: VariableUsage[]): PropertyUsage[] {\n  const propertiesMap = new Map<string, PropertyUsage>();\n\n  for (const usage of usages) {\n    if (usage.property) {\n      const existing = propertiesMap.get(usage.property);\n\n      if (!existing) {\n        // Inferir tipo da propriedade baseado no método chamado\n        let inferredType = 'unknown';\n        let confidence = 50;\n\n        if (usage.method) {\n          const stringMethods = [\n            'toUpperCase',\n            'toLowerCase',\n            'trim',\n            'substring',\n          ];\n          const numberMethods = ['toFixed', 'toPrecision'];\n\n          if (stringMethods.includes(usage.method)) {\n            inferredType = 'string';\n            confidence = 90;\n          } else if (numberMethods.includes(usage.method)) {\n            inferredType = 'number';\n            confidence = 90;\n          }\n        }\n\n        propertiesMap.set(usage.property, {\n          name: usage.property,\n          inferredType,\n          confidence,\n          isOptional: false,\n          methodsCalled: usage.method ? [usage.method] : [],\n        });\n      } else {\n        // Atualizar métodos chamados\n        if (usage.method && !existing.methodsCalled?.includes(usage.method)) {\n          existing.methodsCalled = [\n            ...(existing.methodsCalled || []),\n            usage.method,\n          ];\n        }\n      }\n    }\n  }\n\n  return Array.from(propertiesMap.values());\n}\n\n/**\n * Detecta type guards no código\n */\nfunction detectTypeGuards(usages: VariableUsage[]): TypeGuard[] {\n  const guards: TypeGuard[] = [];\n\n  for (const usage of usages) {\n    const context = usage.context.toLowerCase();\n\n    // typeof guards\n    if (context.includes('typeof')) {\n      const match = context.match(/typeof\\s+\\w+\\s*===\\s*['\"](\\w+)['\"]/);\n      if (match) {\n        guards.push({\n          type: 'typeof',\n          expression: usage.context,\n          inferredType: match[1],\n          confidence: 95,\n        });\n      }\n    }\n\n    // instanceof guards\n    if (context.includes('instanceof')) {\n      const match = context.match(/\\w+\\s+instanceof\\s+(\\w+)/);\n      if (match) {\n        guards.push({\n          type: 'instanceof',\n          expression: usage.context,\n          inferredType: match[1],\n          confidence: 95,\n        });\n      }\n    }\n\n    // 'in' operator guards\n    if (context.includes(' in ')) {\n      const match = context.match(/['\"](\\w+)['\"]\\s+in\\s+\\w+/);\n      if (match) {\n        guards.push({\n          type: 'in',\n          expression: usage.context,\n          inferredType: `{ ${match[1]}: unknown }`,\n          confidence: 80,\n        });\n      }\n    }\n  }\n\n  return guards;\n}\n\n/**\n * Traversa AST recursivamente\n */\nfunction traverseAST(node: unknown, visitor: (node: ASTNode) => void): void {\n  if (!node || typeof node !== 'object') {\n    return;\n  }\n\n  visitor(node as ASTNode);\n\n  for (const key in node as Record<string, unknown>) {\n    if (key === 'loc' || key === 'start' || key === 'end' || key === 'range') {\n      continue; // Skip location metadata\n    }\n\n    const child = (node as Record<string, unknown>)[key];\n\n    if (Array.isArray(child)) {\n      for (const item of child) {\n        traverseAST(item, visitor);\n      }\n    } else if (child && typeof child === 'object') {\n      traverseAST(child, visitor);\n    }\n  }\n}\n\n/**\n * Extrai informações de uso de um nó Identifier\n */\nfunction extractUsageFromNode(\n  node: ASTNode,\n  varName: string,\n): VariableUsage | null {\n  return {\n    name: varName,\n    nodeType: node.type || 'unknown',\n    line: node.loc?.start?.line || 0,\n    column: node.loc?.start?.column || 0,\n    context: extractNodeContext(node),\n    operation: 'access',\n  };\n}\n\n/**\n * Extrai informações de MemberExpression\n */\nfunction extractMemberExpressionUsage(\n  node: ASTNode,\n  varName: string,\n): VariableUsage | null {\n  const property = node.property?.name || (node.property as ASTNode)?.value;\n\n  return {\n    name: varName,\n    nodeType: 'MemberExpression',\n    line: node.loc?.start?.line || 0,\n    column: node.loc?.start?.column || 0,\n    context: extractNodeContext(node),\n    operation: 'access',\n    property: property ? String(property) : undefined,\n  };\n}\n\n/**\n * Extrai informações de CallExpression\n */\nfunction extractCallExpressionUsage(\n  node: ASTNode,\n  varName: string,\n): VariableUsage | null {\n  const method = node.callee?.property?.name;\n\n  return {\n    name: varName,\n    nodeType: 'CallExpression',\n    line: node.loc?.start?.line || 0,\n    column: node.loc?.start?.column || 0,\n    context: extractNodeContext(node),\n    operation: 'call',\n    method: method ? String(method) : undefined,\n  };\n}\n\n/**\n * Extrai contexto ao redor de um nó (para análise)\n */\nfunction extractNodeContext(node: ASTNode): string {\n  // Simplificado - em produção, usar gerador de código do Babel\n  if (node.type === 'Identifier') {\n    return String(node.name || '');\n  }\n\n  if (node.type === 'MemberExpression') {\n    const obj = node.object?.name || extractNodeContext(node.object as ASTNode);\n    const prop = node.property?.name || (node.property as ASTNode)?.value;\n    return `${obj}.${prop}`;\n  }\n\n  if (node.type === 'CallExpression') {\n    const callee = extractNodeContext(node.callee as ASTNode);\n    return `${callee}()`;\n  }\n\n  return String(node.type || '');\n}\n"]}