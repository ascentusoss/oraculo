{"version":3,"file":"type-creator.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/type-creator.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Sistema de criação de arquivos de tipos\n * Cria tipos no diretório configurado (conventions.typesDirectory) com organização correta\n */\n\nimport { promises as fs } from 'node:fs';\nimport path from 'node:path';\n\nimport { buildTypesFsPath } from '@core/config/conventions.js';\n\nimport type { ExistingType, TypeAnalysis } from '@';\n\nimport { toKebabCase } from './context-analyzer.js';\n\n/**\n * Cria definição de tipo no diretório configurado (conventions.typesDirectory)\n */\nexport async function createTypeDefinition(\n  analysis: TypeAnalysis,\n  sourceFilePath: string,\n): Promise<string> {\n  const domain = extractDomain(sourceFilePath);\n  const fileName = toKebabCase(analysis.typeName);\n  const typePath = buildTypesFsPath(path.posix.join(domain, `${fileName}.ts`));\n\n  // Verificar se tipo já existe\n  const existing = await findExistingType(analysis.typeName);\n  if (existing) {\n    // Retornar caminho do alias existente\n    return `@types/types`; // Usar export centralizado\n  }\n\n  // Criar diretório se não existir\n  const dir = path.dirname(typePath);\n  await fs.mkdir(dir, { recursive: true });\n\n  // Gerar conteúdo do arquivo\n  const content = generateTypeFileContent(analysis, sourceFilePath);\n\n  // Escrever arquivo\n  await fs.writeFile(typePath, content, 'utf-8');\n\n  // Adicionar export ao index.ts do domínio\n  await addExportToIndex(domain, fileName);\n\n  // Retornar alias de import\n  return `@types/types`;\n}\n\n/**\n * Busca tipo existente no diretório configurado (conventions.typesDirectory)\n */\nexport async function findExistingType(\n  typeName: string,\n): Promise<ExistingType | null> {\n  try {\n    const tiposDir = buildTypesFsPath('');\n    const types = await scanTypesDirectory(tiposDir);\n\n    for (const type of types) {\n      if (type.name === typeName) {\n        return type;\n      }\n    }\n\n    return null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Verifica se dois tipos são iguais\n */\nexport function isSameType(type1: ExistingType, type2: string): boolean {\n  // Simplificado - em produção, usar parser para comparação estrutural\n  const normalize = (str: string) => str.replace(/\\s+/g, ' ').trim();\n  return normalize(type1.definition) === normalize(type2);\n}\n\n/**\n * Gera conteúdo do arquivo de tipo\n */\nfunction generateTypeFileContent(\n  analysis: TypeAnalysis,\n  sourceFilePath: string,\n): string {\n  const date = new Date().toISOString();\n\n  return `// SPDX-License-Identifier: MIT\n/**\n * Tipo gerado automaticamente\n * Origem: ${sourceFilePath}\n * Confiança: ${analysis.confidence}%\n * Data: ${date}\n *\n * @generated by oraculo fix-any-to-proper-type\n */\n\n${analysis.typeDefinition}\n`;\n}\n\n/**\n * Adiciona export ao index.ts do domínio\n */\nasync function addExportToIndex(\n  domain: string,\n  fileName: string,\n): Promise<void> {\n  const indexPath = buildTypesFsPath(path.posix.join(domain, 'index.ts'));\n\n  try {\n    // Verificar se arquivo index.ts existe\n    await fs.access(indexPath);\n\n    // Ler conteúdo atual\n    const content = await fs.readFile(indexPath, 'utf-8');\n\n    // Verificar se export já existe\n    const exportStatement = `export * from './${fileName}.js';`;\n    if (content.includes(exportStatement)) {\n      return; // Já existe\n    }\n\n    // Adicionar export\n    await fs.appendFile(indexPath, `${exportStatement}\\n`, 'utf-8');\n  } catch {\n    // Criar index.ts se não existir\n    const header = `// SPDX-License-Identifier: MIT\n/**\n * Exports do domínio ${domain}\n */\n\n`;\n    const exportStatement = `export * from './${fileName}.js';\\n`;\n    await fs.writeFile(indexPath, header + exportStatement, 'utf-8');\n  }\n}\n\n/**\n * Extrai domínio do caminho do arquivo\n */\nfunction extractDomain(filePath: string): string {\n  const match = filePath.match(/src[\\\\/]([\\w-]+)[\\\\/]/);\n  return match ? match[1] : 'shared';\n}\n\n/**\n * Escaneia diretório de tipos\n */\nasync function scanTypesDirectory(dir: string): Promise<ExistingType[]> {\n  const types: ExistingType[] = [];\n\n  try {\n    const entries = await fs.readdir(dir, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dir, entry.name);\n\n      if (entry.isDirectory()) {\n        // Recursivo\n        const subTypes = await scanTypesDirectory(fullPath);\n        types.push(...subTypes);\n      } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {\n        // Ler arquivo e extrair tipos\n        const content = await fs.readFile(fullPath, 'utf-8');\n        const extractedTypes = extractTypesFromFile(content, fullPath);\n        types.push(...extractedTypes);\n      }\n    }\n  } catch {\n    // Ignorar erros\n  }\n\n  return types;\n}\n\n/**\n * Extrai tipos de um arquivo\n */\nfunction extractTypesFromFile(\n  content: string,\n  filePath: string,\n): ExistingType[] {\n  const types: ExistingType[] = [];\n\n  // Regex simples para encontrar interfaces e types exportados\n  const interfaceRegex = /export\\s+interface\\s+(\\w+)\\s*{([^}]*)}/g;\n  const typeRegex = /export\\s+type\\s+(\\w+)\\s*=\\s*([^;]+);/g;\n\n  let match;\n\n  // Interfaces\n  while ((match = interfaceRegex.exec(content)) !== null) {\n    types.push({\n      name: match[1],\n      path: filePath,\n      definition: match[0],\n      isExported: true,\n      domain: extractDomain(filePath),\n    });\n  }\n\n  // Types\n  while ((match = typeRegex.exec(content)) !== null) {\n    types.push({\n      name: match[1],\n      path: filePath,\n      definition: match[0],\n      isExported: true,\n      domain: extractDomain(filePath),\n    });\n  }\n\n  return types;\n}\n"]}