{"version":3,"file":"type-analyzer.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/type-analyzer.ts"],"names":[],"mappings":"AAOA,OAAO,EAAE,wBAAwB,EAAE,MAAM,6BAA6B,CAAC;AACvE,OAAO,EAAE,mBAAmB,EAAE,MAAM,yBAAyB,CAAC;AAI9D,OAAO,EACL,mBAAmB,EACnB,qBAAqB,EACrB,gBAAgB,EAChB,oBAAoB,EACpB,gBAAgB,GACjB,MAAM,uBAAuB,CAAC;AAC/B,OAAO,EAAE,kBAAkB,EAAE,MAAM,qBAAqB,CAAC;AACzD,OAAO,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,MAAM,qBAAqB,CAAC;AAK/E,MAAM,CAAC,KAAK,UAAU,gBAAgB,CACpC,KAAuB,EACvB,QAAgB,EAChB,QAAgB,EAChB,GAAgB;IAGhB,MAAM,OAAO,GAAyB;QACpC,QAAQ;QACR,MAAM,EAAE,qBAAqB,CAAC,QAAQ,CAAC;QACvC,YAAY,EAAE,gBAAgB,CAAC,QAAQ,CAAC;QACxC,gBAAgB,EAAE,gBAAgB,CAAC,QAAQ,CAAC;QAC5C,QAAQ,EAAE,oBAAoB,CAAC,QAAQ,CAAC;QACxC,GAAG;QACH,IAAI,EAAE,QAAQ;KACf,CAAC;IAGF,MAAM,OAAO,GAAG,mBAAmB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAErD,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,OAAO;YACL,UAAU,EAAE,CAAC;YACb,YAAY,EAAE,SAAS;YACvB,YAAY,EAAE,KAAK;YACnB,QAAQ,EAAE,EAAE;YACZ,cAAc,EAAE,EAAE;YAClB,aAAa,EAAE,EAAE;YACjB,UAAU,EAAE,mBAAmB,CAAC,KAAK,CAAC,WAAW;SAClD,CAAC;IACJ,CAAC;IAGD,MAAM,MAAM,GAAG,kBAAkB,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAEhD,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO;YACL,UAAU,EAAE,EAAE;YACd,YAAY,EAAE,SAAS;YACvB,YAAY,EAAE,KAAK;YACnB,QAAQ,EAAE,EAAE;YACZ,cAAc,EAAE,EAAE;YAClB,aAAa,EAAE,EAAE;YACjB,UAAU,EAAE,mBAAmB,CAAC,KAAK,CAAC,gBAAgB;SACvD,CAAC;IACJ,CAAC;IAGD,MAAM,QAAQ,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAG9C,MAAM,YAAY,GAAG,kBAAkB,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;IAGrE,IAAI,YAAY,CAAC,aAAa,EAAE,CAAC;QAC/B,YAAY,CAAC,aAAa,GAAG,GAAG,OAAO,CAAC,MAAM,IAAI,YAAY,CAAC,aAAa,EAAE,CAAC;IACjF,CAAC;IAED,OAAO,YAAY,CAAC;AACtB,CAAC;AAKD,MAAM,CAAC,KAAK,UAAU,mBAAmB,CACvC,KAAuB,EACvB,QAAgB,EAChB,QAAgB,EAChB,GAAgB;IAGhB,MAAM,QAAQ,GAAG,MAAM,gBAAgB,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC;IAGxE,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,QAAQ,CAAC,UAAU,GAAG,EAAE,CAAC,CAAC;IAG5D,IAAI,QAAQ,CAAC,UAAU,GAAG,EAAE,EAAE,CAAC;QAC7B,QAAQ,CAAC,UAAU;YACjB,2CAA2C;gBAC3C,6DAA6D,wBAAwB,EAAE,EAAE,CAAC;IAC9F,CAAC;IAED,OAAO,QAAQ,CAAC;AAClB,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Analisador principal de tipos\n * Integra context-analyzer, usage-analyzer e type-inference\n */\n\nimport type { Node } from '@babel/types';\nimport { getTypesDirectoryDisplay } from '@core/config/conventions.js';\nimport { MENSAGENS_FIX_TYPES } from '@core/messages/index.js';\n\nimport type { TypeAnalysis, TypeInferenceContext } from '@';\n\nimport {\n  extractVariableName,\n  getDomainFromFilePath,\n  isDefinitionFile,\n  isLegacyOrVendorFile,\n  isTypeScriptFile,\n} from './context-analyzer.js';\nimport { inferTypeFromUsage } from './type-inference.js';\nimport { analyzeUsagePatterns, findVariableUsages } from './usage-analyzer.js';\n\n/**\n * Analisa uso de any/unknown e infere tipo correto\n */\nexport async function analyzeTypeUsage(\n  match: RegExpMatchArray,\n  fullCode: string,\n  filePath: string,\n  ast: Node | null,\n): Promise<TypeAnalysis> {\n  // 1. Criar contexto de inferência\n  const context: TypeInferenceContext = {\n    filePath,\n    domain: getDomainFromFilePath(filePath),\n    isTypeScript: isTypeScriptFile(filePath),\n    isDefinitionFile: isDefinitionFile(filePath),\n    isLegacy: isLegacyOrVendorFile(filePath),\n    ast,\n    code: fullCode,\n  };\n\n  // 2. Extrair nome da variável\n  const varName = extractVariableName(match, fullCode);\n\n  if (!varName) {\n    return {\n      confidence: 0,\n      inferredType: 'unknown',\n      isSimpleType: false,\n      typeName: '',\n      typeDefinition: '',\n      suggestedPath: '',\n      suggestion: MENSAGENS_FIX_TYPES.erros.extrairNome,\n    };\n  }\n\n  // 3. Encontrar usos da variável no AST\n  const usages = findVariableUsages(varName, ast);\n\n  if (usages.length === 0) {\n    return {\n      confidence: 20,\n      inferredType: 'unknown',\n      isSimpleType: false,\n      typeName: '',\n      typeDefinition: '',\n      suggestedPath: '',\n      suggestion: MENSAGENS_FIX_TYPES.erros.variavelNaoUsada,\n    };\n  }\n\n  // 4. Analisar padrões de uso\n  const patterns = analyzeUsagePatterns(usages);\n\n  // 5. Inferir tipo baseado nos padrões\n  const typeAnalysis = inferTypeFromUsage(varName, patterns, filePath);\n\n  // 6. Ajustar suggestedPath com domínio correto\n  if (typeAnalysis.suggestedPath) {\n    typeAnalysis.suggestedPath = `${context.domain}/${typeAnalysis.suggestedPath}`;\n  }\n\n  return typeAnalysis;\n}\n\n/**\n * Analisa uso de unknown com foco em type guards\n */\nexport async function analyzeUnknownUsage(\n  match: RegExpMatchArray,\n  fullCode: string,\n  filePath: string,\n  ast: Node | null,\n): Promise<TypeAnalysis> {\n  // Mesma lógica de analyzeTypeUsage, mas mais conservador\n  const analysis = await analyzeTypeUsage(match, fullCode, filePath, ast);\n\n  // Penalizar confiança em 10% para unknown (mais conservador)\n  analysis.confidence = Math.max(0, analysis.confidence - 10);\n\n  // Se confiança ainda é baixa, sugerir manter unknown\n  if (analysis.confidence < 70) {\n    analysis.suggestion =\n      'Confiança baixa para substituir unknown. ' +\n      `Considere adicionar type guards ou criar tipo dedicado em ${getTypesDirectoryDisplay()}`;\n  }\n\n  return analysis;\n}\n"]}