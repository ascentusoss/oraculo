{"version":3,"file":"context-analyzer.js","sourceRoot":"","sources":["../../../../src/analistas/corrections/type-safety/context-analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n//  problema-documentacao\n// Justificativa: funções estão tipadas, detector está identificando falsos positivos\n/**\n * Analisador de contexto para Type Safety Auto-Fix\n * Detecta contextos onde any/unknown NÃO devem ser modificados\n */\n\n/**\n * Verifica se posição está dentro de string literal\n *\n * IMPORTANTE: Normaliza line endings para garantir compatibilidade Windows/Linux.\n * Sem isso, arquivos com \\r\\n podem causar problemas de parsing.\n *\n * Ver: docs/reports/DEBUG-TYPE-SAFETY-DETECTOR-2025-11-03.md\n */\n/**\n * Categoriza uso de unknown com nível de confiança\n * Retorna: 'legitimo' | 'melhoravel' | 'corrigir' + confiança (0-100)\n */\nimport type { CategorizacaoUnknown } from '@';\n\nexport function isInString(code: string, position: number): boolean {\n  // Normaliza line endings para \\n (Windows compatibility)\n  const normalizedCode = code.replace(/\\r\\n/g, '\\n');\n  const before = normalizedCode.substring(0, position);\n\n  // Conta aspas simples, duplas e template strings\n  const singleQuotesBefore = (before.match(/(?<!\\\\)'/g) || []).length;\n  const doubleQuotesBefore = (before.match(/(?<!\\\\)\"/g) || []).length;\n  const templateQuotesBefore = (before.match(/(?<!\\\\)`/g) || []).length;\n\n  // Se número ímpar de aspas antes, está dentro de string\n  return (\n    singleQuotesBefore % 2 === 1 ||\n    doubleQuotesBefore % 2 === 1 ||\n    templateQuotesBefore % 2 === 1\n  );\n}\n\n/**\n * Verifica se posição está dentro de comentário\n *\n * CORREÇÕES APLICADAS (2025-11-03):\n * 1. Normalização de line endings (\\r\\n → \\n) para Windows/Linux\n * 2. Lógica corrigida: só marca como comentário se posição está DEPOIS do //\n *    Antes: verificava apenas se havia // na linha (marcava tudo)\n *    Depois: verifica se posInLine >= commentStart\n *\n * Casos de teste:\n * - \"// comentário\\nconst x = 5;\" → linha 2 NÃO está em comentário ✅\n * - \"const x = 5; // comentário\" → \"const x = 5\" NÃO está em comentário ✅\n * - \"const x = 5; // comentário\" → \"// comentário\" ESTÁ em comentário ✅\n *\n * Ver: docs/reports/DEBUG-TYPE-SAFETY-DETECTOR-2025-11-03.md\n */\nexport function isInComment(code: string, position: number): boolean {\n  // Normaliza line endings para \\n (Windows compatibility)\n  const normalizedCode = code.replace(/\\r\\n/g, '\\n');\n  const lines = normalizedCode.split('\\n');\n  let pos = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineStart = pos;\n    const lineEnd = pos + line.length;\n\n    if (position >= lineStart && position <= lineEnd) {\n      // Verifica comentário inline (//)\n      // A posição relativa na linha\n      const posInLine = position - lineStart;\n      const commentStart = line.indexOf('//');\n\n      // Se há // na linha E a posição está depois do //, está em comentário\n      if (commentStart !== -1 && posInLine >= commentStart) {\n        return true;\n      }\n\n      // Verifica comentário de bloco (/* */)\n      const blockStart = normalizedCode.lastIndexOf('/*', position);\n      const blockEnd = normalizedCode.indexOf('*/', position);\n\n      if (blockStart !== -1 && (blockEnd === -1 || blockEnd > position)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    pos = lineEnd + 1; // +1 para o \\n\n  }\n\n  return false;\n} /**\n * Verifica se posição está em string ou comentário\n */\nexport function isInStringOrComment(code: string, position: number): boolean {\n  return isInString(code, position) || isInComment(code, position);\n}\n\n/**\n * Verifica se está em contexto TypeScript específico que deve ser ignorado\n * Exemplos: type annotation em interface, generic constraints, etc\n *\n * IMPORTANTE: NÃO ignora type assertions (as any) - esses são CRÍTICOS\n * e devem ser detectados separadamente como tipo-inseguro-any-assertion.\n *\n * CORREÇÃO APLICADA (2025-11-03):\n * Removida detecção de `as any` que estava ignorando type assertions.\n * Type assertions NÃO são legítimos - são exatamente o que queremos detectar!\n *\n * Ver: docs/reports/DEBUG-TYPE-SAFETY-DETECTOR-2025-11-03.md\n */\nexport function isTypeScriptContext(code: string, position: number): boolean {\n  const context = code.substring(Math.max(0, position - 50), position + 50);\n\n  // NÃO ignorar type assertions - eles são CRÍTICOS e detectados separadamente\n  // O código abaixo foi removido para que as type assertions sejam sempre detectadas\n\n  // Tipo de retorno de função genérica (isso ainda pode ser legítimo em alguns casos)\n  if (/<[^>]*>\\s*\\([^)]*\\)\\s*:\\s*(any|unknown)/.test(context)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Verifica se é arquivo legado ou vendor\n */\nexport function isLegacyOrVendorFile(filePath?: string): boolean {\n  if (!filePath) return false;\n\n  const legacyPatterns = [\n    '/legacy/',\n    '/legado/',\n    '/vendor/',\n    '/node_modules/',\n    '/dist/',\n    '/build/',\n    '.d.ts',\n    '.min.js',\n  ];\n\n  return legacyPatterns.some((pattern) => filePath.includes(pattern));\n}\n\n/**\n * Verifica se unknown está sendo usado em contexto apropriado\n * Contextos apropriados: entrada genérica, APIs externas, deserialização\n */\nexport function isUnknownInGenericContext(\n  code: string,\n  position: number,\n): boolean {\n  const context = code.substring(Math.max(0, position - 200), position + 100);\n\n  // Função genérica com tipo T\n  if (/function\\s+\\w+<T[^>]*>/.test(context)) {\n    return true;\n  }\n\n  // Deserialização (JSON.parse, etc)\n  if (/JSON\\.parse|deserialize|decode/.test(context)) {\n    return true;\n  }\n\n  // API externa ou fetch\n  if (/fetch|axios|request|response\\.data/.test(context)) {\n    return true;\n  }\n\n  // Funções de persistência/serialização que aceitam dados genéricos\n  if (\n    /salvar|persist|save|store|write.*:\\s*\\([^)]*dados:\\s*unknown/.test(context)\n  ) {\n    return true;\n  }\n\n  // Record<string, unknown> - padrão legítimo para objetos genéricos\n  if (/Record<\\s*string\\s*,\\s*unknown\\s*>/.test(context)) {\n    return true;\n  }\n\n  // Array<unknown> ou unknown[] - arrays genéricos\n  if (/Array<\\s*unknown\\s*>|unknown\\s*\\[\\]/.test(context)) {\n    return true;\n  }\n\n  // Parâmetros opcionais genéricos (estilo?: unknown, options?: unknown)\n  if (/\\w+\\?\\s*:\\s*unknown/.test(context)) {\n    return true;\n  } // Type guard function que retorna type predicate\n  if (\n    /function\\s+\\w+\\([^)]*:\\s*unknown\\)[^:]*:\\s*\\w+\\s+is\\s+\\w+/.test(context)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Verifica se any está em declaração de função genérica\n * Nesses casos, pode ser legítimo dependendo do contexto\n */\nexport function isAnyInGenericFunction(\n  code: string,\n  position: number,\n): boolean {\n  const context = code.substring(Math.max(0, position - 300), position + 100);\n\n  // Função de callback genérica\n  if (/callback\\s*:\\s*\\([^)]*:\\s*any/.test(context)) {\n    return true;\n  }\n\n  // Event handler genérico\n  if (/on\\w+\\s*:\\s*\\([^)]*:\\s*any/.test(context)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Extrai domínio do arquivo baseado no caminho\n */\nexport function getDomainFromFilePath(filePath: string): string {\n  const match = filePath.match(/src\\/([\\w-]+)\\//);\n  if (match) {\n    return match[1];\n  }\n\n  // Fallback para 'shared' se não conseguir determinar\n  return 'shared';\n}\n\n/**\n * Converte PascalCase/camelCase para kebab-case\n */\nexport function toKebabCase(str: string): string {\n  return str\n    .replace(/([a-z])([A-Z])/g, '$1-$2')\n    .replace(/[\\s_]+/g, '-')\n    .toLowerCase();\n}\n\n/**\n * Verifica se é arquivo de definição de tipos (.d.ts)\n */\nexport function isDefinitionFile(filePath: string): boolean {\n  return filePath.endsWith('.d.ts');\n}\n\n/**\n * Verifica se é arquivo TypeScript\n */\nexport function isTypeScriptFile(filePath: string): boolean {\n  return filePath.endsWith('.ts') || filePath.endsWith('.tsx');\n}\n\n/**\n * Extrai nome da variável/parâmetro do match\n */\nexport function extractVariableName(\n  match: RegExpMatchArray,\n  code: string,\n): string | null {\n  const position = match.index || 0;\n  const before = code.substring(\n    Math.max(0, position - 100),\n    position + match[0].length,\n  );\n\n  // Padrão: nome: any ou nome: unknown\n  const varMatch = before.match(/(\\w+)\\s*:\\s*(?:any|unknown)\\b/);\n  if (varMatch) {\n    return varMatch[1];\n  }\n\n  return null;\n}\n\n/**\n * Extrai contexto da linha onde o match ocorre\n */\nexport function extractLineContext(code: string, position: number): string {\n  const lines = code.split('\\n');\n  let pos = 0;\n\n  for (const line of lines) {\n    const lineStart = pos;\n    const lineEnd = pos + line.length;\n\n    if (position >= lineStart && position <= lineEnd) {\n      return line;\n    }\n\n    pos = lineEnd + 1;\n  }\n\n  return '';\n}\n\n// Re-exporta para compatibilidade\nexport type { CategorizacaoUnknown };\n\nexport function categorizarUnknown(\n  code: string,\n  filePath: string,\n  lineContext: string,\n): CategorizacaoUnknown {\n  // Type Guards - 100% legítimo\n  if (/:\\s*unknown\\)\\s*:\\s*\\w+\\s+is\\s+/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Type guard padrão TypeScript - unknown é a escolha correta',\n    };\n  }\n\n  // Catch blocks - 100% legítimo\n  if (/catch\\s*\\(\\s*\\w+\\s*:\\s*unknown\\s*\\)/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Catch block padrão TypeScript - unknown é recomendado',\n    };\n  }\n\n  // Índice extensível [k: string]: unknown - 100% legítimo\n  if (/\\[\\s*\\w+\\s*:\\s*string\\s*\\]\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Índice extensível - permite propriedades adicionais',\n    };\n  }\n\n  // Record<string, unknown> ou Map<*, unknown> - 100% legítimo\n  if (\n    /Record<[^,]+,\\s*unknown>/.test(lineContext) ||\n    /Map<[^,]+,\\s*unknown>/.test(lineContext)\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Objeto genérico - Record/Map com unknown é apropriado',\n    };\n  }\n\n  // Array<unknown> ou unknown[] - 100% legítimo\n  if (/Array<unknown>/.test(lineContext) || /unknown\\[\\]/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 100,\n      motivo: 'Array genérico - unknown[] é apropriado',\n    };\n  }\n\n  // Parâmetro opcional com unknown - 95% legítimo\n  if (/\\w+\\?\\s*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Parâmetro opcional - unknown é aceitável',\n      sugestao: 'Considere usar tipo mais específico se o uso for conhecido',\n    };\n  }\n\n  // Guardian related - análise detalhada\n  if (\n    /guardian\\s*:\\s*unknown/.test(lineContext) ||\n    filePath.includes('guardian')\n  ) {\n    if (\n      lineContext.includes('detalhes') ||\n      lineContext.includes('erros') ||\n      lineContext.includes('Error')\n    ) {\n      return {\n        categoria: 'corrigir',\n        confianca: 90,\n        motivo: 'Guardian error details tem estrutura conhecida',\n        sugestao: 'Criar interface GuardianErrorDetails com campos específicos',\n        variantes: [\n          'interface GuardianErrorDetails { message: string; code?: string; stack?: string }',\n          'type GuardianError = Error | { message: string; details?: unknown }',\n          'Usar tipo Error nativo do TypeScript',\n        ],\n      };\n    }\n    return {\n      categoria: 'melhoravel',\n      confianca: 85,\n      motivo: 'Guardian retorna dados não estruturados',\n      sugestao: 'Criar interface GuardianResult com campos conhecidos',\n      variantes: [\n        'interface GuardianResult { status: \"ok\" | \"erro\"; baseline?: Baseline; drift?: Drift }',\n        'type GuardianOutput = SuccessResult | ErrorResult (discriminated union)',\n        'Usar zod/io-ts para validação runtime + tipos',\n      ],\n    };\n  }\n\n  // AST/Babel nodes - 80% melhorável\n  if (\n    /\\bast\\s*:\\s*unknown/.test(lineContext) ||\n    /\\bnode\\s*:\\s*unknown/.test(lineContext) ||\n    lineContext.includes('NodePath')\n  ) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 80,\n      motivo: 'AST deveria ser tipado com Node do /types',\n      sugestao: 'import type { Node } from \"/types\"; usar Node | null',\n      variantes: [\n        'Node (AST node genérico do Babel)',\n        'NodePath<Node> (para traverse)',\n        'File | Program | Statement | Expression (tipos específicos)',\n      ],\n    };\n  }\n\n  // Funções de serialização/persistência - 95% legítimo\n  if (\n    /salvar|persist|save|store|write|serialize|stringify/.test(lineContext) &&\n    /dados\\s*:\\s*unknown|value\\s*:\\s*unknown/.test(lineContext)\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo:\n        'Função de serialização - unknown é apropriado para dados genéricos',\n      sugestao:\n        'Se formato for conhecido, use tipo genérico: <T = unknown>(dados: T) => ...',\n    };\n  }\n\n  // Funções de validação genéricas - 95% legítimo\n  if (\n    /validar|validate|check|assert|guard/.test(lineContext) &&\n    /\\w+\\s*:\\s*unknown/.test(lineContext)\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Função de validação - recebe unknown e valida tipo',\n    };\n  }\n\n  // Acesso dinâmico protegido (safeGet) - 95% legítimo\n  if (\n    /safeGet|tryGet|getProperty/.test(lineContext) &&\n    /:\\s*unknown/.test(lineContext) &&\n    !/:\\s*unknown\\)/.test(lineContext)\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Acesso dinâmico protegido - retorno é unknown por segurança',\n      sugestao:\n        'Validar tipo após obter valor: const val = safeGet(...); if (typeof val === ...)',\n    };\n  }\n\n  // Replacer functions em JSON - 95% legítimo\n  if (\n    /replacer|reviver/.test(lineContext) &&\n    /\\w+\\s*:\\s*unknown/.test(lineContext)\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Replacer/reviver do JSON - unknown é esperado',\n    };\n  }\n\n  // Wrappers de AST/parsing - 95% legítimo\n  if (\n    /wrap|parse|transform/.test(lineContext) &&\n    /ast\\s*:\\s*unknown|rawAst\\s*:\\s*unknown/.test(lineContext)\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Wrapper de parser - AST de origem desconhecida',\n    };\n  }\n\n  // Funções de error handling - 95% legítimo\n  if (\n    /error\\s*:\\s*unknown|err\\s*:\\s*unknown|e\\s*:\\s*unknown/.test(lineContext) &&\n    (/extrair|extract|format|parse/.test(lineContext) ||\n      filePath.includes('validacao'))\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo:\n        'Error handling - error pode ser de qualquer tipo em catch/callbacks',\n    };\n  }\n\n  // Mock/test utilities - 95% legítimo\n  if (/mock|vitest|expect|args\\s*:\\s*unknown\\[\\]/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Test utilities - tipos genéricos de framework de testes',\n    };\n  }\n\n  // CLI options/callbacks - 95% legítimo quando vem de framework\n  if (\n    /opts\\s*:\\s*unknown|options\\s*:\\s*unknown/.test(lineContext) &&\n    (filePath.includes('cli') || /aplicar|process|handle/.test(lineContext))\n  ) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'CLI framework callback - opts validado downstream',\n    };\n  }\n\n  // Propriedades de índice dinâmico em type assertions - 95% legítimo\n  if (/as\\s+unknown\\s+as\\s+\\{[^}]*:\\s*unknown/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo: 'Type assertion para acesso dinâmico - padrão de compatibilidade',\n    };\n  }\n\n  // Callbacks/handlers genéricos - análise contextual\n  if (/(opts|options|params|args)\\s*:\\s*unknown/.test(lineContext)) {\n    if (filePath.includes('cli') || filePath.includes('comando')) {\n      return {\n        categoria: 'legitimo',\n        confianca: 85,\n        motivo: 'Callback CLI - opts será validado downstream',\n        sugestao: 'Considere tipar se a interface for conhecida',\n        variantes: [\n          'CommandOptions (interface do commander.js)',\n          'Record<string, string | boolean | number> (CLI flags genéricos)',\n          'Usar zod schema para validação + inferência de tipos',\n        ],\n      };\n    }\n    return {\n      categoria: 'melhoravel',\n      confianca: 70,\n      motivo: 'Parâmetro genérico - pode ser mais específico',\n      sugestao: 'Definir interface específica para os parâmetros',\n      variantes: [\n        'interface FunctionOptions { timeout?: number; verbose?: boolean; ... }',\n        'Partial<KnownConfig> (se for subset de config)',\n        'Usar tipo genérico com constraint: <T extends BaseOptions>',\n      ],\n    };\n  }\n\n  // Filter/map com unknown - 75% melhorável\n  if (/filter\\s*\\(/.test(lineContext) || /map\\s*\\(/.test(lineContext)) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 75,\n      motivo: 'Array operation com tipo genérico - pode inferir tipo do array',\n      sugestao: 'Tipar o array pai para propagar tipos automaticamente',\n      variantes: [\n        'Especificar tipo do array: items: Item[] em vez de items: unknown[]',\n        'Usar generics: function filter<T>(items: T[], predicate: (item: T) => boolean)',\n        'Inferir do contexto: const typed = items as KnownType[]',\n      ],\n    };\n  }\n\n  // Relatórios/fragmentação - 70% melhorável\n  if (\n    filePath.includes('relatorio') ||\n    filePath.includes('fragmentar') ||\n    lineContext.includes('Manifest')\n  ) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 70,\n      motivo: 'Dados de relatório - estrutura pode ser definida',\n      sugestao: 'Criar interfaces específicas para estruturas de dados',\n      variantes: [\n        'interface RelatorioCompleto { summary: Summary; detalhes: Detalhe[]; ... }',\n        'interface ManifestPart { id: string; tipo: string; conteudo: unknown }',\n        'type RelatorioJson = { version: string; data: Record<string, unknown> }',\n      ],\n    };\n  }\n\n  // Compatibilidade de módulos - 95% legítimo\n  if (filePath.includes('chalk-safe') || /import\\s*\\(/.test(lineContext)) {\n    return {\n      categoria: 'legitimo',\n      confianca: 95,\n      motivo:\n        'Compatibilidade ESM/CJS - unknown necessário para imports dinâmicos',\n      sugestao: 'Pode adicionar type assertion após validação runtime',\n    };\n  }\n\n  // Análise de contexto amplo quando específico falha\n  const contextoAmplo = code.substring(\n    Math.max(0, lineContext.length - 300),\n    lineContext.length + 200,\n  );\n\n  // Verifica se há validação/type guard próximo\n  if (\n    /typeof\\s+\\w+\\s*===/.test(contextoAmplo) ||\n    /instanceof/.test(contextoAmplo) ||\n    /is\\w+\\(/.test(contextoAmplo)\n  ) {\n    return {\n      categoria: 'melhoravel',\n      confianca: 65,\n      motivo:\n        'Há validação de tipo próxima - pode extrair para type guard dedicado',\n      sugestao:\n        'Criar função type guard: function isTipoX(obj: unknown): obj is TipoX { ... }',\n      variantes: [\n        'Extrair validações para type guard reutilizável',\n        'Usar biblioteca de validação (zod, yup, io-ts) para runtime + types',\n        'Criar branded types se for validação complexa',\n      ],\n    };\n  }\n\n  // Default: melhorável com análise incerta\n  return {\n    categoria: 'melhoravel',\n    confianca: 60,\n    motivo: 'Tipo unknown genérico - análise contextual limitada',\n    sugestao: 'Analisar fluxo de dados para inferir tipo correto',\n    variantes: [\n      'Se vem de API externa: definir interface baseada na resposta esperada',\n      'Se é callback: especificar assinatura da função',\n      'Se é config/options: criar interface com campos opcionais',\n      'Se é polimórfico: considerar discriminated union ou generics',\n    ],\n  };\n}\n"]}