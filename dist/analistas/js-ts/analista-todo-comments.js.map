{"version":3,"file":"analista-todo-comments.js","sourceRoot":"","sources":["../../../src/analistas/js-ts/analista-todo-comments.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\nimport type { NodePath } from '/traverse';\nimport type { Comment } from '/types';\nimport { TodoCommentsMessages } from '/messages/analistas/analista-todo-comments-messages.js';\nimport { detectarContextoProjeto } from '/contexto-projeto.js';\n\nimport type { Analista, TecnicaAplicarResultado } from '@';\nimport { criarOcorrencia } from '@';\n\n// Evita warning de unused import - função usada em runtime\nvoid detectarContextoProjeto;\n\n// Analista simples para detectar TODO em comentários (//, /* */), ignorando testes/specs\nexport const analistaTodoComments: Analista = {\n  nome: 'todo-comments',\n  categoria: 'qualidade',\n  descricao:\n    'Detecta comentários TODO deixados no código (apenas em comentários).',\n  // Per-file (não global): executa por arquivo\n  global: false,\n  test(relPath) {\n    // Usa o sistema de contexto inteligente\n    const contextoArquivo = detectarContextoProjeto({\n      arquivo: relPath,\n      conteudo: '',\n      relPath,\n    });\n\n    // Ignora testes, configs e infraestrutura\n    if (\n      contextoArquivo.isTest ||\n      contextoArquivo.isConfig ||\n      contextoArquivo.frameworks.includes('types')\n    ) {\n      return false;\n    }\n\n    // Evita auto-detecção neste próprio arquivo\n    if (/analistas[\\\\\\/]analista-todo-comments\\.(ts|js)$/i.test(relPath))\n      return false;\n    return /\\.(ts|js|tsx|jsx)$/i.test(relPath);\n  },\n  aplicar(src, relPath, ast?: NodePath | null): TecnicaAplicarResultado {\n    // Aplicar contexto inteligente\n    const contextoArquivo = detectarContextoProjeto({\n      arquivo: relPath,\n      conteudo: src,\n      relPath,\n    });\n\n    // Nível baseado no contexto\n    const nivelTodo = contextoArquivo.isLibrary ? 'aviso' : 'info';\n\n    const RE_TODO_START = /^TODO\\b/i;\n    const RE_TODO_ANY = /\\bTODO\\b\\s*[:\\-(\\[]/i;\n\n    // Detecta se o TODO é parte de um template JSDoc gerado automaticamente\n    const isJSDocTemplate = (\n      linha: string,\n      _linhaAnterior?: string,\n    ): boolean => {\n      // Padrões típicos de JSDoc templates automáticos\n      const templatePatterns = [\n        /\\*\\s*TODO:\\s*Adicionar descrição da função\\s*$/i,\n        /\\*\\s*\\s+\\{[^}]*\\}\\s+\\w+\\s*-\\s*TODO:\\s*Descrever parâmetro\\s*$/i,\n        /\\*\\s*\\s+\\{[^}]*\\}\\s*TODO:\\s*Descrever retorno\\s*$/i,\n      ];\n\n      return templatePatterns.some((pattern) => pattern.test(linha));\n    };\n\n    const isTodoComment = (\n      texto: string,\n      linhaCompleta?: string,\n      linhaAnterior?: string,\n    ): boolean => {\n      const t = String(texto ?? '').trim();\n      const isTodo = RE_TODO_START.test(t) || RE_TODO_ANY.test(t);\n\n      // Se é TODO, verifica se é template JSDoc\n      if (\n        isTodo &&\n        linhaCompleta &&\n        isJSDocTemplate(linhaCompleta, linhaAnterior)\n      ) {\n        return false; // Ignora TODOs em templates JSDoc\n      }\n\n      return isTodo;\n    };\n\n    // Localiza marcadores de comentário ignorando ocorrências dentro de strings (', \", `)\n    const localizarMarcadores = (\n      linha: string,\n    ): { lineIdx: number; blockIdx: number } => {\n      let inS = false;\n      let inD = false;\n      let inB = false;\n      let prev = '';\n      for (let i = 0; i < linha.length; i++) {\n        const ch = linha[i];\n        const pair = prev + ch;\n        // alterna estados de string considerando escapes simples\n        if (!inD && !inB && ch === \"'\" && prev !== '\\\\') inS = !inS;\n        else if (!inS && !inB && ch === '\"' && prev !== '\\\\') inD = !inD;\n        else if (!inS && !inD && ch === '`' && prev !== '\\\\') inB = !inB;\n\n        // apenas quando não dentro de strings detectar comentários\n        if (!inS && !inD && !inB) {\n          if (pair === '//') {\n            return { lineIdx: i - 1, blockIdx: -1 };\n          }\n          if (pair === '/*') {\n            return { lineIdx: -1, blockIdx: i - 1 };\n          }\n        }\n        prev = ch;\n      }\n      return { lineIdx: -1, blockIdx: -1 };\n    };\n    if (!src || typeof src !== 'string') return null;\n    // Evita auto-detecção neste próprio arquivo (defesa dupla)\n    if (/analistas[\\\\\\/]analista-todo-comments\\.(ts|js)$/i.test(relPath))\n      return null;\n\n    // Caminho preferencial: usar comentários da AST quando disponível\n    if (ast && ast.node) {\n      const maybeWithComments = ast.node as unknown as { comments?: Comment[] };\n      if (Array.isArray(maybeWithComments.comments)) {\n        const comments = maybeWithComments.comments;\n        const ocorrencias = comments\n          .filter((c) => {\n            const texto = String(c.value ?? '').trim();\n            // Para comentários AST, não temos acesso fácil ao contexto de linha\n            // Vamos usar uma heurística mais simples aqui\n            return isTodoComment(texto);\n          })\n          .map((c) =>\n            criarOcorrencia({\n              tipo: 'TODO-pendente',\n              mensagem: TodoCommentsMessages.todoFound,\n              nivel: nivelTodo,\n              relPath,\n              linha: c.loc?.start.line,\n              origem: 'todo-comments',\n            }),\n          );\n        return ocorrencias.length ? ocorrencias : null;\n      }\n    }\n\n    // Heurística: considera TODO apenas quando presente em comentários\n    const linhas = src.split(/\\r?\\n/);\n    const ocorrenciasLinhas: number[] = [];\n    let emBloco = false;\n    for (let i = 0; i < linhas.length; i++) {\n      const linha = linhas[i];\n      let analisada = false;\n\n      // Verifica comentários de bloco (/* ... */)\n      if (emBloco) {\n        analisada = true;\n        const linhaAnterior = i > 0 ? linhas[i - 1] : undefined;\n        if (isTodoComment(linha, linha, linhaAnterior)) {\n          ocorrenciasLinhas.push(i + 1);\n        }\n        if (linha.includes('*/')) {\n          emBloco = false;\n        }\n      }\n\n      if (!analisada) {\n        // Procura início de bloco e comentário de linha ignorando strings\n        const { blockIdx: idxBlockStart, lineIdx: idxLine } =\n          localizarMarcadores(linha);\n\n        // Caso comentário de linha\n        if (idxLine >= 0 && (idxBlockStart === -1 || idxLine < idxBlockStart)) {\n          const trechoComentario = linha.slice(idxLine + 2);\n          const linhaAnterior = i > 0 ? linhas[i - 1] : undefined;\n          if (isTodoComment(trechoComentario, linha, linhaAnterior)) {\n            ocorrenciasLinhas.push(i + 1);\n          }\n          continue;\n        }\n\n        // Caso bloco começando nesta linha\n        if (idxBlockStart >= 0) {\n          const trechoAposInicio = linha.slice(idxBlockStart + 2);\n          const linhaAnterior = i > 0 ? linhas[i - 1] : undefined;\n          if (isTodoComment(trechoAposInicio, linha, linhaAnterior)) {\n            ocorrenciasLinhas.push(i + 1);\n          }\n          if (!linha.includes('*/')) {\n            emBloco = true;\n          }\n          continue;\n        }\n      }\n    }\n\n    if (ocorrenciasLinhas.length === 0) return null;\n\n    return ocorrenciasLinhas.map((linha) =>\n      criarOcorrencia({\n        tipo: 'TODO-pendente',\n        mensagem: TodoCommentsMessages.todoFound,\n        nivel: nivelTodo,\n        relPath,\n        linha,\n        origem: 'todo-comments',\n      }),\n    );\n  },\n};\n\nexport default analistaTodoComments;\n"]}