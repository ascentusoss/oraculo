{"version":3,"file":"detector-interfaces-inline.js","sourceRoot":"","sources":["../../../src/analistas/detectores/detector-interfaces-inline.ts"],"names":[],"mappings":"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","sourcesContent":["// SPDX-License-Identifier: MIT\n/**\n * Detector de Interfaces Inline\n * Identifica definições de interfaces e tipos complexos inline que deveriam estar em arquivos de tipos\n *\n * Estratégia:\n * - Detecta interfaces inline em funções, classes e variáveis\n * - Identifica tipos complexos que deveriam ser extraídos\n * - Sugere movimentação para o diretório de tipos configurado (conventions.typesDirectory)\n * - Analisa reutilização e complexidade para priorizar extrações\n */\n\nimport type { NodePath } from '@babel/traverse';\nimport type { Node } from '@babel/types';\nimport {\n  getTypesDirectoryDisplay,\n  isInsideTypesDirectory,\n} from '@core/config/conventions.js';\nimport { DetectorInterfacesInlineMessages } from '@core/messages/analistas/detector-interfaces-inline-messages.js';\n\nimport type { Analista, InterfaceInlineDetection, Ocorrencia } from '@';\n\nconst ANALISTA: Analista = {\n  nome: 'detector-interfaces-inline',\n  categoria: 'code-organization',\n  descricao:\n    'Detecta interfaces e tipos complexos inline que deveriam estar em arquivos de tipos',\n\n  test: (relPath: string) => {\n    // Não analisar arquivos que já estão na pasta de tipos\n    if (isInsideTypesDirectory(relPath)) {\n      return false;\n    }\n\n    // Não analisar arquivos de definição de tipos do TypeScript\n    if (relPath.endsWith('.d.ts')) {\n      return false;\n    }\n\n    // Não analisar arquivos deprecados\n    if (\n      relPath.includes('/.deprecados/') ||\n      relPath.includes('\\\\.deprecados\\\\')\n    ) {\n      return false;\n    }\n\n    // Não analisar node_modules\n    if (\n      relPath.includes('/node_modules/') ||\n      relPath.includes('\\\\node_modules\\\\')\n    ) {\n      return false;\n    }\n\n    return relPath.endsWith('.ts') || relPath.endsWith('.tsx');\n  },\n\n  aplicar: async (\n    srcParam: string,\n    relPath: string,\n    _ast: NodePath<Node> | null,\n    _fullPath?: string,\n  ): Promise<Ocorrencia[]> => {\n    const ocorrencias: Ocorrencia[] = [];\n\n    // Normalização de line endings\n    const src = srcParam.replace(/\\r\\n/g, '\\n');\n    const _linhas = src.split('\\n');\n\n    // 1. Detectar interfaces inline em funções EXPORTADAS\n    // Funções locais podem ter tipos inline simples sem problema\n    const interfaceInlinePattern =\n      /export\\s+function\\s+\\w+\\s*\\([^)]*\\):\\s*{[^}]+}/g;\n    let match: RegExpMatchArray | null;\n\n    while ((match = interfaceInlinePattern.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      const detection = analyzeInlineInterface(\n        match[0],\n        linha,\n        'function-return',\n      );\n      // Aumentar threshold para 5 propriedades em tipos de retorno\n      if (detection && detection.complexidade >= 5) {\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 2. Detectar tipos literais complexos em parâmetros\n    // Apenas reportar parâmetros realmente complexos (5+ propriedades)\n    const complexParamPattern = /\\w+\\s*:\\s*{\\s*[^}]+;\\s*[^}]+;\\s*[^}]+}/g;\n\n    while ((match = complexParamPattern.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      const detection = analyzeInlineInterface(match[0], linha, 'parameter');\n      // Aumentar threshold para 5 propriedades em parâmetros\n      if (detection && detection.complexidade >= 5) {\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 3. Detectar type aliases inline com uniões complexas\n    // Buscar declarações de type e depois extrair o conteúdo completo\n    const typeStartPattern = /type\\s+(\\w+)\\s*=/g;\n    let startMatch: RegExpMatchArray | null;\n\n    while ((startMatch = typeStartPattern.exec(src)) !== null) {\n      const position = startMatch.index || 0;\n      const nomeTipo = startMatch[1];\n\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      // Extrair o tipo completo (até o próximo ponto-e-vírgula no nível raiz)\n      const afterEquals = src.substring(position + startMatch[0].length);\n      const tipoCompleto = extractTypeDefinition(afterEquals);\n\n      if (!tipoCompleto) {\n        continue;\n      }\n\n      const linha = src.substring(0, position).split('\\n').length;\n      const complexidade = calculateComplexidade(tipoCompleto);\n\n      // Aumentar threshold para 5 propriedades em type aliases\n      if (complexidade >= 5) {\n        const detection: InterfaceInlineDetection = {\n          tipo: 'type-alias',\n          nome: nomeTipo,\n          linha,\n          complexidade,\n          contexto: tipoCompleto.substring(0, 100),\n          sugestao:\n            DetectorInterfacesInlineMessages.moverTipoParaTipos(nomeTipo),\n        };\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 4. Detectar interfaces exportadas inline (PRIORIDADE MÁXIMA)\n    // Pattern para capturar 'export interface Nome' de forma precisa\n    const exportInterfacePattern =\n      /export\\s+interface\\s+(\\w+)\\s*(<[^>]*>)?\\s*\\{/g;\n    while ((match = exportInterfacePattern.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n      const nomeInterface = match[1];\n\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      // Interfaces exportadas SEMPRE devem estar em tipos/\n      const detection: InterfaceInlineDetection = {\n        tipo: 'interface',\n        nome: nomeInterface,\n        linha,\n        complexidade: 0, // Não importa - exportada sempre reporta\n        contexto: `export interface ${nomeInterface}`,\n        sugestao:\n          DetectorInterfacesInlineMessages.interfaceExportadaParaTipos(\n            nomeInterface,\n          ),\n      };\n      ocorrencias.push(createOcorrencia(detection, relPath));\n    }\n\n    // 5. Detectar interfaces declaradas inline (não exportadas, mas complexas)\n    // Pattern melhorado para capturar interfaces multi-linha\n    const interfaceDeclarationPattern =\n      /(?<!export\\s+)interface\\s+(\\w+)\\s*\\{[\\s\\S]+?\\}/g;\n    while ((match = interfaceDeclarationPattern.exec(src)) !== null) {\n      const position = match.index || 0;\n      const linha = src.substring(0, position).split('\\n').length;\n      const nomeInterface = match[1];\n\n      if (isInStringOrComment(src, position)) {\n        continue;\n      }\n\n      // Verificar se não foi já detectada como exportada\n      const jaDetetada = ocorrencias.some(\n        (o) => o.linha === linha && o.mensagem?.includes(nomeInterface),\n      );\n      if (jaDetetada) {\n        continue;\n      }\n\n      // Verificar se interface é local (começa com minúscula)\n      const isLocal = /^[a-z]/.test(nomeInterface);\n\n      // Só reportar se for complexa e não for local\n      const interfaceCompleta = match[0];\n      const complexidade = calculateComplexidade(interfaceCompleta);\n\n      if (complexidade >= 4 && !isLocal) {\n        const detection: InterfaceInlineDetection = {\n          tipo: 'interface',\n          nome: nomeInterface,\n          linha,\n          complexidade,\n          contexto: interfaceCompleta.substring(0, 100),\n          sugestao:\n            DetectorInterfacesInlineMessages.interfaceComplexaParaTipos(\n              nomeInterface,\n            ),\n        };\n        ocorrencias.push(createOcorrencia(detection, relPath));\n      }\n    }\n\n    // 6. Detectar tipos inline repetidos (possível duplicação)\n    const tiposInline = extractAllInlineTypes(src);\n    const tiposRepetidos = findDuplicateTypes(tiposInline);\n\n    for (const [estrutura, ocorrenciasArray] of tiposRepetidos.entries()) {\n      const totalOcorrencias = ocorrenciasArray.length;\n      const primeiraOcorrencia = ocorrenciasArray[0];\n\n      // Extrair assinatura das propriedades para mensagem\n      const propriedades = estrutura\n        .split(';')\n        .map((p) => p.split(':')[0])\n        .slice(0, 3);\n      const nomesSugeridos = propriedades.join('_');\n\n      // Detectar contextos de uso\n      const contextosUnicos = [\n        ...new Set(ocorrenciasArray.map((o) => o.contexto)),\n      ];\n      const contextoDesc =\n        contextosUnicos.length > 1\n          ? `em ${contextosUnicos.length} contextos diferentes`\n          : 'no mesmo contexto';\n\n      ocorrencias.push({\n        tipo: 'interface-inline-duplicada',\n        nivel: 'aviso',\n        mensagem: DetectorInterfacesInlineMessages.tipoDuplicado({\n          propriedades,\n          totalOcorrencias,\n          contextoDesc,\n          nomesSugeridos,\n        }),\n        relPath,\n        linha: primeiraOcorrencia.linha,\n        detalhes: {\n          estrutura,\n          ocorrencias: ocorrenciasArray.length,\n          linhas: ocorrenciasArray.map((o) => o.linha),\n          contextos: contextosUnicos,\n        },\n      } as Ocorrencia);\n    }\n\n    return ocorrencias;\n  },\n};\n\n/**\n * Analisa uma interface inline e determina se deve ser extraída\n */\nfunction analyzeInlineInterface(\n  code: string,\n  linha: number,\n  contexto: 'function-return' | 'parameter' | 'variable',\n): InterfaceInlineDetection | null {\n  const tiposDirDisplay = getTypesDirectoryDisplay();\n  const complexidade = calculateComplexidade(code);\n\n  // Só reportar se for realmente complexo (5+ propriedades)\n  if (complexidade < 5) {\n    return null;\n  }\n\n  let sugestao = '';\n  switch (contexto) {\n    case 'function-return':\n      sugestao = `Extrair tipo de retorno para interface em ${tiposDirDisplay}`;\n      break;\n    case 'parameter':\n      sugestao = `Extrair tipo de parâmetro para interface em ${tiposDirDisplay}`;\n      break;\n    case 'variable':\n      sugestao = `Extrair tipo da variável para interface em ${tiposDirDisplay}`;\n      break;\n  }\n\n  return {\n    tipo: 'object-literal-type',\n    linha,\n    complexidade,\n    contexto: code.substring(0, 100),\n    sugestao,\n  };\n}\n\n/**\n * Calcula complexidade de um tipo baseado em propriedades, união, interseção, etc\n */\nfunction calculateComplexidade(tipoString: string): number {\n  let score = 0;\n\n  // Contar propriedades: cada `;` ou `,` seguido de algo indica uma propriedade\n  // Também conta `:` para capturar propriedades sem separador final\n  const propriedadesMultilinha = (tipoString.match(/[;:]\\s*\\n/g) || []).length;\n  const propriedadesInline = (tipoString.match(/;\\s*\\w+\\s*:/g) || []).length;\n  const propriedadesTotal = (tipoString.match(/\\w+\\s*\\??\\s*:/g) || []).length;\n\n  // Usar o maior valor entre as contagens (sem fator de redução para inline)\n  score += Math.max(\n    propriedadesMultilinha,\n    propriedadesInline + 1,\n    propriedadesTotal,\n  );\n\n  // Contar operadores de união\n  const unioes = (tipoString.match(/\\|/g) || []).length;\n  score += unioes * 0.5;\n\n  // Contar operadores de interseção\n  const intersecoes = (tipoString.match(/&/g) || []).length;\n  score += intersecoes * 0.5;\n\n  // Contar genéricos aninhados\n  const genericosAninhados = (tipoString.match(/<[^>]*</g) || []).length;\n  score += genericosAninhados * 2;\n\n  // Contar arrays e objetos aninhados\n  const aninhamento = (tipoString.match(/{\\s*\\w+\\s*:/g) || []).length;\n  score += aninhamento;\n\n  return Math.floor(score);\n}\n\n/**\n * Extrai estrutura normalizada de propriedades de um tipo objeto\n */\nfunction extractTypeStructure(tipoString: string): string {\n  // Extrair apenas nomes e tipos das propriedades, ignorando valores específicos\n  const props: string[] = [];\n\n  // Pattern melhorado para capturar propriedades com seus tipos\n  const propPattern = /(\\w+)\\??\\s*:\\s*([^;,}]+)/g;\n  let match: RegExpMatchArray | null;\n\n  while ((match = propPattern.exec(tipoString)) !== null) {\n    const propName = match[1];\n    let propType = match[2].trim();\n\n    // Normalizar tipos comuns\n    propType = propType\n      .replace(/\\s+/g, ' ')\n      .replace(/string|number|boolean|null|undefined/gi, (m) => m.toLowerCase())\n      .replace(/\\[\\]/g, 'Array')\n      .replace(/Record<[^>]+>/g, 'Record')\n      .replace(/Promise<[^>]+>/g, 'Promise')\n      .trim();\n\n    props.push(`${propName}:${propType}`);\n  }\n\n  // Retornar assinatura normalizada ordenada\n  return props.sort().join(';');\n}\n\n/**\n * Extrai todos os tipos inline do código com estrutura normalizada\n */\nfunction extractAllInlineTypes(\n  src: string,\n): Array<{ tipo: string; estrutura: string; linha: number; contexto: string }> {\n  const tipos: Array<{\n    tipo: string;\n    estrutura: string;\n    linha: number;\n    contexto: string;\n  }> = [];\n\n  // Pattern melhorado para capturar objetos tipo literal (incluindo multi-linha)\n  // Procura por padrões como: { prop: type, ... } em contextos de tipo\n  const lines = src.split('\\n');\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    // Detectar início de tipo objeto literal\n    // Contextos: : { ... }, < { ... }, = { ... } (em tipos, não valores)\n    const typeObjStart = /[:=<]\\s*\\{\\s*$/;\n    const inlineTypeObj = /:\\s*\\{[^}]+\\}/g;\n\n    // Tentar match inline simples primeiro\n    let match: RegExpMatchArray | null;\n    while ((match = inlineTypeObj.exec(line)) !== null) {\n      const matchIndex = match.index ?? 0;\n      const position =\n        src.substring(0, src.indexOf(lines.slice(0, i + 1).join('\\n'))).length +\n        matchIndex;\n\n      if (!isInStringOrComment(src, position)) {\n        const tipoOriginal = match[0].substring(match[0].indexOf('{'));\n        const complexidade = calculateComplexidade(tipoOriginal);\n\n        if (complexidade >= 4) {\n          const estrutura = extractTypeStructure(tipoOriginal);\n          const contexto = line\n            .substring(0, matchIndex)\n            .trim()\n            .substring(0, 60);\n          const linha = i + 1;\n\n          tipos.push({\n            tipo: tipoOriginal.replace(/\\s+/g, ' ').trim(),\n            estrutura,\n            linha,\n            contexto,\n          });\n        }\n      }\n    }\n\n    // Detectar objetos tipo multi-linha\n    if (typeObjStart.test(line) && !line.includes('//')) {\n      let depth = 1;\n      const tipoLines: string[] = ['{'];\n      let j = i + 1;\n\n      while (j < lines.length && depth > 0) {\n        const nextLine = lines[j];\n        tipoLines.push(nextLine);\n\n        // Contar abertura/fechamento de chaves (simplificado)\n        for (const char of nextLine) {\n          if (char === '{') depth++;\n          if (char === '}') depth--;\n          if (depth === 0) break;\n        }\n\n        j++;\n        if (j - i > 50) break; // Limite de segurança\n      }\n\n      if (depth === 0) {\n        const tipoOriginal = tipoLines.join('\\n').trim();\n        const position = src.indexOf(tipoOriginal);\n\n        if (position !== -1 && !isInStringOrComment(src, position)) {\n          const complexidade = calculateComplexidade(tipoOriginal);\n\n          if (complexidade >= 4) {\n            const estrutura = extractTypeStructure(tipoOriginal);\n            const contexto = line\n              .substring(0, line.indexOf('{'))\n              .trim()\n              .substring(0, 60);\n            const linha = i + 1;\n\n            tipos.push({\n              tipo: tipoOriginal.replace(/\\s+/g, ' ').trim(),\n              estrutura,\n              linha,\n              contexto,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return tipos;\n}\n\n/**\n * Encontra tipos inline duplicados com base na estrutura normalizada\n */\nfunction findDuplicateTypes(\n  tipos: Array<{\n    tipo: string;\n    estrutura: string;\n    linha: number;\n    contexto: string;\n  }>,\n): Map<string, Array<{ linha: number; tipo: string; contexto: string }>> {\n  const mapa = new Map<\n    string,\n    Array<{ linha: number; tipo: string; contexto: string }>\n  >();\n\n  // Agrupar por estrutura normalizada (não por tipo literal exato)\n  for (const { estrutura, linha, tipo, contexto } of tipos) {\n    if (!mapa.has(estrutura)) {\n      mapa.set(estrutura, []);\n    }\n    const arr = mapa.get(estrutura);\n    if (arr) {\n      arr.push({ linha, tipo, contexto });\n    }\n  }\n\n  // Filtrar apenas duplicados significativos\n  const duplicados = new Map<\n    string,\n    Array<{ linha: number; tipo: string; contexto: string }>\n  >();\n\n  for (const [estrutura, ocorrencias] of mapa.entries()) {\n    // Critérios mais refinados:\n    // - >= 4 ocorrências: duplicação clara que deve ser extraída\n    // - >= 3 ocorrências com contextos diferentes: possível tipo comum\n    const contextosUnicos = new Set(ocorrencias.map((o) => o.contexto)).size;\n\n    if (\n      ocorrencias.length >= 4 ||\n      (ocorrencias.length >= 3 && contextosUnicos >= 2)\n    ) {\n      duplicados.set(estrutura, ocorrencias);\n    }\n  }\n\n  return duplicados;\n}\n\n/**\n * Cria ocorrência a partir de uma detecção\n */\nfunction createOcorrencia(\n  detection: InterfaceInlineDetection,\n  relPath: string,\n): Ocorrencia {\n  const tiposDirDisplay = getTypesDirectoryDisplay();\n  let tipo = '';\n  let nivel: 'info' | 'aviso' | 'erro' = 'info';\n  let mensagem = '';\n\n  switch (detection.tipo) {\n    case 'interface':\n      tipo = 'interface-inline-exportada';\n      nivel = 'aviso';\n      mensagem = detection.nome\n        ? `Interface '${detection.nome}' deve estar em ${tiposDirDisplay}`\n        : `Interface inline deve estar em ${tiposDirDisplay}`;\n      break;\n    case 'type-alias':\n      tipo = 'type-alias-inline-complexo';\n      nivel = 'aviso';\n      mensagem = detection.nome\n        ? `Tipo '${detection.nome}' complexo deve estar em ${tiposDirDisplay}`\n        : `Tipo complexo deve estar em ${tiposDirDisplay}`;\n      break;\n    case 'object-literal-type':\n      tipo = 'tipo-literal-inline-complexo';\n      nivel = 'info';\n      mensagem = `Tipo literal complexo (${detection.complexidade} propriedades) - considere extrair`;\n      break;\n  }\n\n  return {\n    tipo,\n    nivel,\n    mensagem,\n    relPath,\n    linha: detection.linha,\n  } as Ocorrencia;\n} /**\n * Extrai definição completa de um tipo a partir do ponto após o '='\n */\nfunction extractTypeDefinition(afterEquals: string): string | null {\n  let depth = 0;\n  let inString = false;\n  let stringChar = '';\n  let result = '';\n\n  for (let i = 0; i < afterEquals.length; i++) {\n    const char = afterEquals[i];\n    const prevChar = i > 0 ? afterEquals[i - 1] : '';\n\n    // Controle de strings\n    if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n      if (inString && char === stringChar) {\n        inString = false;\n      } else if (!inString) {\n        inString = true;\n        stringChar = char;\n      }\n    }\n\n    if (inString) {\n      result += char;\n      continue;\n    }\n\n    // Contar chaves\n    if (char === '{' || char === '<' || char === '[' || char === '(') {\n      depth++;\n    } else if (char === '}' || char === '>' || char === ']' || char === ')') {\n      depth--;\n    }\n\n    result += char;\n\n    // Parar no ponto-e-vírgula no nível raiz\n    if (char === ';' && depth === 0) {\n      return result;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Verifica se posição está dentro de string ou comentário\n */\nfunction isInStringOrComment(src: string, position: number): boolean {\n  const beforePosition = src.substring(0, position);\n  const linha = beforePosition.split('\\n').pop() || '';\n\n  // Comentário de linha\n  if (linha.includes('//')) {\n    const commentPos = linha.indexOf('//');\n    const posInLine =\n      beforePosition.length - beforePosition.lastIndexOf('\\n') - 1;\n    if (posInLine > commentPos) {\n      return true;\n    }\n  }\n\n  // Comentário de bloco\n  const lastBlockCommentStart = beforePosition.lastIndexOf('/*');\n  const lastBlockCommentEnd = beforePosition.lastIndexOf('*/');\n  if (lastBlockCommentStart > lastBlockCommentEnd) {\n    return true;\n  }\n\n  // String (aspas simples ou duplas)\n  const singleQuotes = (beforePosition.match(/'/g) || []).length;\n  const doubleQuotes = (beforePosition.match(/\"/g) || []).length;\n  const backticks = (beforePosition.match(/`/g) || []).length;\n\n  return (\n    singleQuotes % 2 !== 0 || doubleQuotes % 2 !== 0 || backticks % 2 !== 0\n  );\n}\n\nexport default ANALISTA;\n"]}