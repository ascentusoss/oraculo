{"version":3,"file":"persistencia.js","sourceRoot":"","sources":["../../../src/shared/persistence/persistencia.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,QAAQ,IAAI,EAAE,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,KAAK,IAAI,MAAM,SAAS,CAAC;AAChC,OAAO,IAAI,MAAM,WAAW,CAAC;AAE7B,OAAO,EAAE,gBAAgB,EAAE,MAAM,0CAA0C,CAAC;AAS5E,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC;AAC3B,MAAM,OAAO,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE,CAAC,KAAK,EAAE,CAAC;AAElD,SAAS,OAAO,CACd,GAAM,EACN,GAAM;IAEN,IAAI,CAAC;QAEH,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;IAClB,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,SAAS,CAAC;IACnB,CAAC;AACH,CAAC;AAED,SAAS,gBAAgB,CAAC,OAAe;IAGvC,IACE,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE,CAAC,KAAK,EAAE;QACjC,OAAO,CAAC,GAAG,CAAC,wBAAwB,KAAK,GAAG;QAE5C,OAAO;IACT,MAAM,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IACvC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CACb,gBAAgB,CAAC,iCAAiC,CAAC,OAAO,CAAC,CAC5D,CAAC;IACJ,CAAC;AACH,CAAC;AAUD,SAAS,YAAY,CAAC,CAAY;IAChC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,SAAS;QAAE,OAAO,CAAC,CAAC;IAC5C,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;QAAE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;IACjE,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE,CAAC;QAC1B,MAAM,YAAY,GAAG,CAA8B,CAAC;QACpD,MAAM,GAAG,GAA8B,EAAE,CAAC;QAC1C,KAAK,MAAM,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,IAAI,EAAE;YAC9C,GAAG,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;QACzC,OAAO,GAAG,CAAC;IACb,CAAC;IACD,OAAO,CAAC,CAAC;AACX,CAAC;AAED,SAAS,eAAe,CAAC,KAAc;IAErC,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,KAAkB,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACnE,CAAC;AAMD,MAAM,CAAC,KAAK,UAAU,SAAS,CAC7B,OAAe,EACf,MAAU;IAEV,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,MAAM,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACtD,IAAI,CAAC;YACH,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAM,CAAC;QACnC,CAAC;QAAC,MAAM,CAAC;YAEP,OAAQ,MAAY,IAAK,EAAmB,CAAC;QAC/C,CAAC;IACH,CAAC;IAAC,MAAM,CAAC;QACP,OAAQ,MAAY,IAAK,EAAmB,CAAC;IAC/C,CAAC;AACH,CAAC;AAGD,KAAK,UAAU,gBAAgB,CAC7B,OAAe,EACf,KAAQ;IAER,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAC1B,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAClC,MAAM,SAAS,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC;IACvE,MAAM,QAAQ,GAAG,OAAO,KAAK,KAAK,QAAQ,CAAC;IAC3C,MAAM,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAE,KAAgB,CAAC,CAAC,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;IACtE,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAC5B,GAAG,EACH,YAAY,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CACxE,CAAC;IAEF,MAAM,aAAa,CAAC,YAAY,EAAE,OAAO,EAAE;QACzC,QAAQ,EAAE,OAAO;QACjB,IAAI,EAAE,KAAK;KACZ,CAAC,CAAC;IACH,MAAM,UAAU,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;AAC1C,CAAC;AAGD,MAAM,CAAC,IAAI,YAAY,GAAmB,gBAAgB,CAAC;AAG3D,IAAI,CAAC;IACH,MAAM,OAAO,GAAI,UAA8B,CAAC,EAAE,CAAC;IACnD,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,EAAE,KAAK,UAAU,EAAE,CAAC;QAE3D,YAAY,GAAI,OAAO,CAAC,EAAkD,CACxE,KAAK,EAAE,GAAG,IAAuB,EAAE,EAAE,CACnC,gBAAgB,CAAC,GAAI,IAA0B,CAAC,CACtB,CAAC;IACjC,CAAC;AACH,CAAC;AAAC,MAAM,CAAC,CAAA,CAAC;AAIV,MAAM,CAAC,KAAK,UAAU,eAAe,CAAC,OAAe;IACnD,IAAI,CAAC;QACH,OAAO,MAAM,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAC9C,CAAC;IAAC,MAAM,CAAC;QACP,OAAO,EAAE,CAAC;IACZ,CAAC;AACH,CAAC;AAGD,MAAM,CAAC,KAAK,UAAU,mBAAmB,CACvC,OAAe,EACf,KAAQ;IAER,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAC1B,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAClC,MAAM,SAAS,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;IACvD,MAAM,YAAY,GAAG,IAAI,CAAC,IAAI,CAC5B,GAAG,EACH,QAAQ,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CACjE,CAAC;IACF,MAAM,OAAO,GAAG,eAAe,CAAC,KAAK,CAAC,CAAC;IACvC,MAAM,aAAa,CAAC,YAAY,EAAE,OAAO,EAAE;QACzC,QAAQ,EAAE,OAAO;QACjB,IAAI,EAAE,KAAK;KACZ,CAAC,CAAC;IACH,MAAM,UAAU,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;AAC1C,CAAC;AAMD,MAAM,CAAC,KAAK,UAAU,oBAAoB,CACxC,OAAe,EACf,KAAa;IAEb,gBAAgB,CAAC,OAAO,CAAC,CAAC;IAC1B,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAClC,MAAM,SAAS,CAAC,GAAG,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC;IACvD,MAAM,cAAc,GAAG,IAAI,CAAC,IAAI,CAC9B,GAAG,EACH,QAAQ,IAAI,CAAC,GAAG,EAAE,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,CAChE,CAAC;IAGF,MAAM,CAAC,GAAG,EAMT,CAAC;IACF,IAAI,OAAO,CAAC,CAAC,SAAS,KAAK,UAAU,EAAE,CAAC;QACtC,MAAM,CAAC,CAAC,SAAS,CAAC,cAAc,EAAE,KAAK,CAAC,CAAC;QACzC,MAAM,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;QAC1C,OAAO;IACT,CAAC;IAED,MAAM,OAAO,GAAG,OAAO,CACrB,IAA0C,EAC1C,WAAW,CACZ,CAAC;IACF,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE,CAAC;QAClC,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAExC,OAKD,CAAC,cAAc,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QACrE,CAAC,CAAC,CAAC;QACH,MAAM,UAAU,CAAC,cAAc,EAAE,OAAO,CAAC,CAAC;QAC1C,OAAO;IACT,CAAC;IAED,IAAI,OAAO;QAAE,OAAO;IACpB,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,6BAA6B,CAAC,CAAC;AAClE,CAAC;AAGD,MAAM,CAAC,IAAI,aAAa,GAAoB,oBAAoB,CAAC;AAEjE,IAAI,CAAC;IACH,MAAM,QAAQ,GAAI,UAA8B,CAAC,EAAE,CAAC;IACpD,IAAI,OAAO,IAAI,QAAQ,IAAI,OAAO,QAAQ,CAAC,EAAE,KAAK,UAAU,EAAE,CAAC;QAC7D,aAAa,GACX,QAAQ,CAAC,EACV,CAAC,KAAK,EAAE,GAAG,IAAsB,EAAE,EAAE,CACpC,oBAAoB,CAAC,GAAG,IAAI,CAAC,CACA,CAAC;IAClC,CAAC;AACH,CAAC;AAAC,MAAM,CAAC,CAAA,CAAC;AAIV,KAAK,UAAU,YAAY,CACzB,QAAgB,EAChB,QAAyB;IAEzB,MAAM,CAAC,GAAG,EAET,CAAC;IACF,IAAI,OAAO,CAAC,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC;QACrC,OAAO,MAAM,CAAC,CAAC,QAAQ,CAAC,QAAQ,EAAE,QAAQ,IAAI,OAAO,CAAC,CAAC;IACzD,CAAC;IAED,MAAM,MAAM,GAAG,OAAO,CAAC,IAAyC,EAAE,UAAU,CAAC,CAAC;IAC9E,IAAI,OAAO,MAAM,KAAK,UAAU,EAAE,CAAC;QACjC,OAAO,MAAM,IAAI,OAAO,CAAS,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAEjD,MAKD,CAAC,QAAQ,EAAE,QAAQ,IAAI,OAAO,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;gBAC7C,IAAI,GAAG;oBAAE,MAAM,CAAC,GAAG,CAAC,CAAC;;oBAChB,OAAO,CAAC,IAAI,CAAC,CAAC;YACrB,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;IAED,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,CAAC;AAC3D,CAAC;AAED,KAAK,UAAU,aAAa,CAC1B,QAAgB,EAChB,IAAY,EACZ,OAAsD;IAEtD,MAAM,CAAC,GAAG,EAMT,CAAC;IACF,IAAI,OAAO,CAAC,CAAC,SAAS,KAAK,UAAU,EAAE,CAAC;QACtC,MAAM,CAAC,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3C,OAAO;IACT,CAAC;IAED,MAAM,OAAO,GAAG,OAAO,CACrB,IAA0C,EAC1C,WAAW,CACZ,CAAC;IACF,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE,CAAC;QAClC,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAExC,OAMD,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QACvE,CAAC,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IAED,IAAI,OAAO;QAAE,OAAO;IACpB,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,uBAAuB,CAAC,CAAC;AAC5D,CAAC;AAED,KAAK,UAAU,UAAU,CAAC,OAAe,EAAE,OAAe;IACxD,MAAM,CAAC,GAAG,EAET,CAAC;IACF,IAAI,OAAO,CAAC,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;QACnC,MAAM,CAAC,CAAC,MAAM,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACjC,OAAO;IACT,CAAC;IACD,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAuC,EAAE,QAAQ,CAAC,CAAC;IAC5E,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE,CAAC;QACnC,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAExC,QAKD,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAChE,CAAC,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IACD,IAAI,OAAO;QAAE,OAAO;IACpB,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;AACzD,CAAC;AAED,KAAK,UAAU,SAAS,CACtB,OAAe,EACf,OAAgD;IAEhD,MAAM,CAAC,GAAG,EAKT,CAAC;IACF,IAAI,OAAO,CAAC,CAAC,KAAK,KAAK,UAAU,EAAE,CAAC;QAClC,MAAM,CAAC,CAAC,KAAK,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAChC,OAAO;IACT,CAAC;IACD,MAAM,OAAO,GAAG,OAAO,CAAC,IAAsC,EAAE,OAAO,CAAC,CAAC;IACzE,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE,CAAC;QAClC,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAExC,OAKD,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;QAChE,CAAC,CAAC,CAAC;QACH,OAAO;IACT,CAAC;IACD,IAAI,OAAO;QAAE,OAAO;IACpB,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;AACxD,CAAC","sourcesContent":["// SPDX-License-Identifier: MIT\n// @oraculo-disable tipo-inseguro-unknown\n// Justificativa: unknown é usado para serialização genérica que aceita qualquer entrada\nimport { promises as fs } from 'node:fs';\nimport * as fsCb from 'node:fs';\nimport path from 'node:path';\n\nimport { ExcecoesMessages } from '@core/messages/core/excecoes-messages.js';\n\nimport type {\n  GlobalComVitest,\n  SalvarBinarioFn,\n  SalvarEstadoFn,\n  VitestSpyWrapper,\n} from '@';\n\nconst ROOT = process.cwd();\nconst IS_TEST = (process.env.VITEST ?? '') !== '';\n\nfunction safeGet<T extends object, K extends PropertyKey>(\n  obj: T,\n  key: K,\n): unknown {\n  try {\n    // @ts-expect-error acesso dinâmico protegido\n    return obj[key];\n  } catch {\n    return undefined;\n  }\n}\n\nfunction assertInsideRoot(caminho: string): void {\n  // Permite fora da raiz explicitamente em testes ou quando habilitado\n  // Qualquer valor truthy em VITEST deve liberar a restrição (Vitest define VITEST=\"true\")\n  if (\n    (process.env.VITEST ?? '') !== '' ||\n    process.env.ORACULO_ALLOW_OUTSIDE_FS === '1'\n  )\n    return;\n  const resolved = path.resolve(caminho);\n  if (!resolved.startsWith(path.resolve(ROOT))) {\n    throw new Error(\n      ExcecoesMessages.persistenciaNegadaForaRaizProjeto(caminho),\n    );\n  }\n}\n\ntype JSONValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\nfunction sortKeysDeep(v: JSONValue): JSONValue {\n  if (v === null || v === undefined) return v;\n  if (Array.isArray(v)) return v.map((item) => sortKeysDeep(item));\n  if (typeof v === 'object') {\n    const configObject = v as Record<string, JSONValue>;\n    const out: Record<string, JSONValue> = {};\n    for (const k of Object.keys(configObject).sort())\n      out[k] = sortKeysDeep(configObject[k]);\n    return out;\n  }\n  return v;\n}\n\nfunction stableStringify(dados: unknown): string {\n  // Serialização genérica: aceita entrada arbitrária e converte para JSON válido\n  return JSON.stringify(sortKeysDeep(dados as JSONValue), null, 2);\n}\n\n/**\n * Lê e desserializa um arquivo JSON de estado.\n * Fallback: retorna [] para compatibilidade com formas antigas ou objeto vazio quando apropriado.\n */\nexport async function lerEstado<T = unknown>(\n  caminho: string,\n  padrao?: T,\n): Promise<T> {\n  try {\n    const conteudo = await readFileSafe(caminho, 'utf-8');\n    try {\n      return JSON.parse(conteudo) as T; // sucesso JSON\n    } catch {\n      // Compatibilidade com testes/versões antigas: se JSON inválido retorna []\n      return (padrao as T) ?? ([] as unknown as T);\n    }\n  } catch {\n    return (padrao as T) ?? ([] as unknown as T);\n  }\n}\n\n/** Escrita atômica com permissões restritas e fsync. */\nasync function salvarEstadoImpl<T = unknown>(\n  caminho: string,\n  dados: T,\n): Promise<void> {\n  assertInsideRoot(caminho);\n  const dir = path.dirname(caminho);\n  await mkdirSafe(dir, { recursive: true, mode: 0o700 }).catch(() => {});\n  const isString = typeof dados === 'string';\n  const payload = isString ? (dados as string) : stableStringify(dados);\n  const tempFilePath = path.join(\n    dir,\n    `.tmp-bin-${Date.now()}-${Math.random().toString(16).slice(2)}.oraculo`,\n  );\n  // Escreve diretamente com fs.promises para manter compat em ambientes mockados\n  await writeFileSafe(tempFilePath, payload, {\n    encoding: 'utf-8',\n    mode: 0o600,\n  });\n  await renameSafe(tempFilePath, caminho);\n}\n\n// Export reatribuível: em testes, será embrulhado por vi.fn para permitir spies em chamadas\nexport let salvarEstado: SalvarEstadoFn = salvarEstadoImpl;\n\n// Em ambiente de testes (Vitest), se disponível global vi.fn, usa wrapper spy\ntry {\n  const maybeVi = (globalThis as GlobalComVitest).vi;\n  if (IS_TEST && maybeVi && typeof maybeVi.fn === 'function') {\n    // Garante que o spy invoque a implementação real por padrão\n    salvarEstado = (maybeVi.fn as unknown as VitestSpyWrapper<SalvarEstadoFn>)(\n      async (...args: [string, unknown]) =>\n        salvarEstadoImpl(...(args as [string, unknown])),\n    ) as unknown as SalvarEstadoFn;\n  }\n} catch {}\n\n// Leitura bruta de arquivo de texto (sem parse JSON). Uso para conteúdo fonte.\n\nexport async function lerArquivoTexto(caminho: string): Promise<string> {\n  try {\n    return await readFileSafe(caminho, 'utf-8');\n  } catch {\n    return '';\n  }\n}\n\n/** Escrita atômica: grava em tmp e renomeia. */\nexport async function salvarEstadoAtomico<T = unknown>(\n  caminho: string,\n  dados: T,\n): Promise<void> {\n  assertInsideRoot(caminho);\n  const dir = path.dirname(caminho);\n  await mkdirSafe(dir, { recursive: true, mode: 0o700 });\n  const tempFilePath = path.join(\n    dir,\n    `.tmp-${Date.now()}-${Math.random().toString(16).slice(2)}.json`,\n  );\n  const payload = stableStringify(dados);\n  await writeFileSafe(tempFilePath, payload, {\n    encoding: 'utf-8',\n    mode: 0o600,\n  });\n  await renameSafe(tempFilePath, caminho);\n}\n\n/**\n * Escrita binária atômica: grava Buffer em arquivo temporário e renomeia.\n * Usa os mesmos mecanismos resilientes a mocks do restante do módulo.\n */\nexport async function salvarBinarioAtomico(\n  caminho: string,\n  dados: Buffer,\n): Promise<void> {\n  assertInsideRoot(caminho);\n  const dir = path.dirname(caminho);\n  await mkdirSafe(dir, { recursive: true, mode: 0o700 });\n  const temporaryValue = path.join(\n    dir,\n    `.tmp-${Date.now()}-${Math.random().toString(16).slice(2)}.bin`,\n  );\n\n  // Tenta usar fs.promises.writeFile se disponível para Buffer\n  const p = fs as unknown as {\n    writeFile?: (\n      p: string,\n      d: Buffer | string,\n      o?: { encoding?: BufferEncoding; mode?: number },\n    ) => Promise<void>;\n  };\n  if (typeof p.writeFile === 'function') {\n    await p.writeFile(temporaryValue, dados);\n    await renameSafe(temporaryValue, caminho);\n    return;\n  }\n\n  const cbWrite = safeGet(\n    fsCb as unknown as { writeFile?: unknown },\n    'writeFile',\n  );\n  if (typeof cbWrite === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (\n        cbWrite as (\n          p: string,\n          d: Buffer,\n          cb: (err: NodeJS.ErrnoException | null) => void,\n        ) => void\n      )(temporaryValue, dados, (err) => (err ? reject(err) : resolve()));\n    });\n    await renameSafe(temporaryValue, caminho);\n    return;\n  }\n\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMessages.fsWriteFileBinaryIndisponivel);\n}\n\n// Export reatribuível para permitir spies em testes\nexport let salvarBinario: SalvarBinarioFn = salvarBinarioAtomico;\n\ntry {\n  const maybeVi2 = (globalThis as GlobalComVitest).vi;\n  if (IS_TEST && maybeVi2 && typeof maybeVi2.fn === 'function') {\n    salvarBinario = (\n      maybeVi2.fn as unknown as VitestSpyWrapper<SalvarBinarioFn>\n    )(async (...args: [string, Buffer]) =>\n      salvarBinarioAtomico(...args),\n    ) as unknown as SalvarBinarioFn;\n  }\n} catch {}\n\n// --- Fallbacks resilientes a mocks parciais de fs.promises ---\n\nasync function readFileSafe(\n  pathname: string,\n  encoding?: BufferEncoding,\n): Promise<string> {\n  const p = fs as unknown as {\n    readFile?: (p: string, e: BufferEncoding) => Promise<string>;\n  };\n  if (typeof p.readFile === 'function') {\n    return await p.readFile(pathname, encoding ?? 'utf-8');\n  }\n  // Callback API fallback\n  const cbRead = safeGet(fsCb as unknown as { readFile?: unknown }, 'readFile');\n  if (typeof cbRead === 'function') {\n    return await new Promise<string>((resolve, reject) => {\n      (\n        cbRead as (\n          p: string,\n          e: BufferEncoding,\n          cb: (err: NodeJS.ErrnoException | null, data: string) => void,\n        ) => void\n      )(pathname, encoding ?? 'utf-8', (err, data) => {\n        if (err) reject(err);\n        else resolve(data);\n      });\n    });\n  }\n  // Em ambiente de teste com mock total de fs, deixe o caller lidar via try/catch\n  throw new Error(ExcecoesMessages.fsReadFileIndisponivel);\n}\n\nasync function writeFileSafe(\n  pathname: string,\n  data: string,\n  options?: { encoding?: BufferEncoding; mode?: number },\n): Promise<void> {\n  const p = fs as unknown as {\n    writeFile?: (\n      p: string,\n      d: string,\n      o?: { encoding?: BufferEncoding; mode?: number },\n    ) => Promise<void>;\n  };\n  if (typeof p.writeFile === 'function') {\n    await p.writeFile(pathname, data, options);\n    return;\n  }\n  // Callback API fallback\n  const cbWrite = safeGet(\n    fsCb as unknown as { writeFile?: unknown },\n    'writeFile',\n  );\n  if (typeof cbWrite === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (\n        cbWrite as (\n          p: string,\n          d: string,\n          o: { encoding?: BufferEncoding; mode?: number } | undefined,\n          cb: (err: NodeJS.ErrnoException | null) => void,\n        ) => void\n      )(pathname, data, options, (err) => (err ? reject(err) : resolve()));\n    });\n    return;\n  }\n  // Em testes com fs totalmente mockado, considere no-op para escrita\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMessages.fsWriteFileIndisponivel);\n}\n\nasync function renameSafe(oldPath: string, newPath: string): Promise<void> {\n  const p = fs as unknown as {\n    rename?: (o: string, n: string) => Promise<void>;\n  };\n  if (typeof p.rename === 'function') {\n    await p.rename(oldPath, newPath);\n    return;\n  }\n  const cbRename = safeGet(fsCb as unknown as { rename?: unknown }, 'rename');\n  if (typeof cbRename === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (\n        cbRename as (\n          o: string,\n          n: string,\n          cb: (err: NodeJS.ErrnoException | null) => void,\n        ) => void\n      )(oldPath, newPath, (err) => (err ? reject(err) : resolve()));\n    });\n    return;\n  }\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMessages.fsRenameIndisponivel);\n}\n\nasync function mkdirSafe(\n  dirPath: string,\n  options?: { recursive?: boolean; mode?: number },\n): Promise<void> {\n  const p = fs as unknown as {\n    mkdir?: (\n      p: string,\n      o?: { recursive?: boolean; mode?: number },\n    ) => Promise<void>;\n  };\n  if (typeof p.mkdir === 'function') {\n    await p.mkdir(dirPath, options);\n    return;\n  }\n  const cbMkdir = safeGet(fsCb as unknown as { mkdir?: unknown }, 'mkdir');\n  if (typeof cbMkdir === 'function') {\n    await new Promise<void>((resolve, reject) => {\n      (\n        cbMkdir as (\n          p: string,\n          o: { recursive?: boolean; mode?: number } | undefined,\n          cb: (err: NodeJS.ErrnoException | null) => void,\n        ) => void\n      )(dirPath, options, (err) => (err ? reject(err) : resolve()));\n    });\n    return;\n  }\n  if (IS_TEST) return;\n  throw new Error(ExcecoesMessages.fsMkdirIndisponivel);\n}\n"]}